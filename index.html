<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>步步为营，勇往直前</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="步步为营，勇往直前">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="步步为营，勇往直前">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="步步为营，勇往直前">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="步步为营，勇往直前" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">步步为营，勇往直前</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">赵培霏的学习博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/16/HTTP/" class="article-date">
  <time datetime="2016-05-16T06:37:38.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/HTTP/">HTTP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP（HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端进行资源请求和应答的标准。</p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><h4 id="get-获取资源"><a href="#get-获取资源" class="headerlink" title="get 获取资源"></a>get 获取资源</h4><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的资源是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。</p>
<h4 id="post-传输实体主体"><a href="#post-传输实体主体" class="headerlink" title="post 传输实体主体"></a>post 传输实体主体</h4><p>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取相应的主体内容。</p>
<h4 id="head-获得报文首部"><a href="#head-获得报文首部" class="headerlink" title="head 获得报文首部"></a>head 获得报文首部</h4><p>HEAD方法与GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>
<h4 id="option-询问支持的方法"><a href="#option-询问支持的方法" class="headerlink" title="option 询问支持的方法"></a>option 询问支持的方法</h4><p>用来查询这对请求URI指定的资源支持的方法。</p>
<h4 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h4><p>参考：<a href="https://segmentfault.com/a/1190000004014583#articleHeader7" target="_blank" rel="external">GET请求和POST请求的区别</a> <a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="external">HTTP方法：GET对比POST</a></p>
<ul>
<li>在HTTP/1.1中，get被强制服务器支持，即服务器必须实现get方法</li>
<li>浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li>
<li>POST请求相对GET请求是相对安全的。因为get请求会将数据添加到url后，普通人都可以看到。而post则需要进行抓包才可以看到。所以说相对安全。</li>
<li>在规范的定义下，GET操作不会修改服务器的数据<br><img src="/img/计算机基础/get和post的区别.png" alt=""></li>
</ul>
<h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><p>HTTP报文主要由报文首部和报文主体构成（中间以空行分界）。请求报文首部由请求行（方法 URI HTTP版本）、请求首部字段、通用首部字段、实体首部字段和其他首部组成。响应报文首部由状态行（HTTP版本 状态码）、响应首部字段、通用首部字段、实体首部字段和其他首部组成。</p>
<h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><ul>
<li><p>Cache-Control 控制缓存的行为，更多请查看<a href="http://baike.baidu.com/link?url=DKZzZAkL3zDoA0PHRZU2hytroVcR3bRad8MplCbsnH9bfKH6XDL8MdVlGQyORnSa6fbtUuvOc9IMnsW_mje1x_" target="_blank" rel="external">百度百科</a><br>  |Cache指令|说明|<br>  |:——-:|:–:|<br>  |public      |所有内容都将被缓存(客户端和代理服务器都可缓存)|<br>  |private  |内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)|<br>  |no-cache |必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。|<br>  |no-store |所有内容都不会被缓存到缓存或 Internet 临时文件中|<br>  |must-revalidation/proxy-revalidation |如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证|<br>  |max-age=xxx (xxx is numeric)|缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高|</p>
</li>
<li><p>Connection：管理持久连接、控制不再转发给代理的首部字段。Keep-Alive：持久连接，HTTP/1.1版本和2.0版本都默认持久连接，在遇到Connection为close时，才会断开连接。</p>
</li>
<li>Date：表明创建HTTP报文的日期和时间。</li>
<li>Pragma：与HTTP/1.0兼容的字段，设为no-cache要求所有的中间服务器不返回缓存的资源。</li>
<li>Transfer-Encoding：规定传输报文主体时采用的编码方式。如gzip、chunked等</li>
<li>Upgrade：用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。使用方法为：Upgrade：TLS/1.0 Connection：Upgrade</li>
</ul>
<h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><ul>
<li>Accept：能够处理的媒体类型及媒体类型的相对优先级，如text/html、text/css、image/png等</li>
<li>Accept-Encoding：支持的内容编码及内容编码的优先级，如gzip、compress等</li>
<li>Accept-Language：支持的自然语言集及相对优先级，如zh-cn、en-us等</li>
<li>Host：虚拟主机运行在同一个IP上时，使用Host加以区分</li>
<li>If-Modified-Since：如果在该字段指定的日期后，资源发生了更新，服务器会接收请求</li>
<li>If-None-Match：如果没有该Etag相匹配，处理该请求。可在get或head方法中使用它可获取最新的资源。</li>
<li>Referer：会告知服务器请求的原始资源的URI，即哪个web页面发起的请求。</li>
<li>User-Agent：创建请求的浏览器和用户代理名称等信息</li>
</ul>
<h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><ul>
<li>Etag：每个资源的唯一性标识，资源更新，则Etag更新。</li>
<li>Location：配合3**重定向响应，提供重定向的URI。</li>
<li>Server：服务器上安装的HTTP服务器应用程序的信息。</li>
</ul>
<h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><ul>
<li>Allow：服务器支持的所有HTTP方法，使用option方法可返回该字段</li>
<li>Content-Encoding：实体的主体部分选用的内容编码方式。</li>
<li>Content-Language：如zh-CN</li>
<li>Content-Length：实体主体部分的大小（单位为字节）</li>
<li>Content-Type：实体主体内对象的媒体类型。如text/html等</li>
<li>Expires：资源失效的日期</li>
<li>Last-Modified：资源最后修改的时间</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>Set-Cookie：status=enable；expires：Tue，05 Jul 2011 07:26:31 GMT；path=/;domain:.hackr.jp;（NAME=VALUE以及失效期、目录、域名等）Secure表示仅在HTTPS下才发送Cookie，HttpOnly，表示Cookie不能被JavaScript脚本访问。</li>
<li>Cookie：发送cookie名称及相应的值</li>
<li>X-XSS-Protection：针对跨站脚本攻击（XSS）的一种对策。0：将XSS过滤设置成无效状态；1：有效状态</li>
</ul>
<h2 id="常用TTTP码"><a href="#常用TTTP码" class="headerlink" title="常用TTTP码"></a>常用TTTP码</h2><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><ul>
<li>101 转换协议<h4 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h4></li>
<li>200：服务器已成功处理了请求并提供了请求的网页。</li>
<li>204：服务器成功处理了请求，但没有返回任何内容。<h4 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h4></li>
<li>301：请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。</li>
<li>302：请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL</li>
<li>304：如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。<h4 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h4></li>
<li>400：服务器不理解请求的语法。</li>
<li>403：服务器拒绝请求。</li>
<li>404：服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。</li>
<li>410：请求的资源永久删除后，服务器返回此响应。该代码与404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404页面代码。如果资源已永久删除，应当使用301指定资源的新位置。<h4 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h4></li>
<li>500：服务器遇到错误，无法完成请求。</li>
<li>503：服务器目前无法使用（由于超载或停机维护）。</li>
<li>505：HTTP版本不受支持。</li>
</ul>
<h2 id="域名、URL、网站名"><a href="#域名、URL、网站名" class="headerlink" title="域名、URL、网站名"></a>域名、URL、网站名</h2><p><a href="http://mail.163.com/index.html" target="_blank" rel="external">http://mail.163.com/index.html</a></p>
<ul>
<li>http:// 这是个协议，即http超文本传输协议，也就是网页在网上传输的协议。</li>
<li>mail 这个是服务器名，代表一个邮箱服务器</li>
<li>163.com 这个是域名，是用来定位网站的独一无二的名字</li>
<li>mail.163.com 这个是网站名，由服务器名+域名组成</li>
<li>index.html 这个是根目录下得默认网页</li>
<li>整体叫做URL，统一资源定位符，定位网上资源。由协议 + 服务器 + 域名 + 网页html组成</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>1997年，HTTP1.1问世。HTTP1.0中出现的最大问题使连接无法复用和队头阻塞问题。针对连接无法复用问题，HTTP1.1通过connection实现长连接，针对队头阻塞问题，HTTP1.1提出管线化（然而存在很多缺陷，所以并没有被广泛使用）。</p>
<h4 id="客户端-服务器端"><a href="#客户端-服务器端" class="headerlink" title="客户端/服务器端"></a>客户端/服务器端</h4><p>仅从一条通信路线来说，应用HTTP协议时，必定一端担任客户端角色，另一端担任服务器角色。客户端发送请求，服务器端才能响应，不能实现服务器端推送功能。为了实现服务器端推送功能，就必须使用Comet等解决方法（保留响应直到服务器内容更新）。</p>
<h4 id="不保存状态的协议"><a href="#不保存状态的协议" class="headerlink" title="不保存状态的协议"></a>不保存状态的协议</h4><p>HTTP是一种不保存状态的协议，但为了实现期望的保持状态功能，于是引入了Cookie技术，但是该技术在很大程度上使首部膨胀，增加了数据传输压力，进而增加延迟。</p>
<h4 id="采用明文传输"><a href="#采用明文传输" class="headerlink" title="采用明文传输"></a>采用明文传输</h4><p>首部采用明文传输，所以首部数据量大，且不安全。为保证安全，要使用HTTPS协议。</p>
<h4 id="仍然存在队头阻塞问题"><a href="#仍然存在队头阻塞问题" class="headerlink" title="仍然存在队头阻塞问题"></a>仍然存在队头阻塞问题</h4><p>由于http1.1管线技术的缺陷，使用率较小。为了解决这个问题，主要使用图片合并、文件合并、内容内嵌等技术来减小请求次数，但是会导致文件粒度变大。</p>
<h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><p>SPDY针对HTTP1.1的痛点——延迟和安全性，从协议层次进行了技术改革，SPDY位于HTTP之下，TCP和SSL之上，实现了多路复用、请求优先级、header压缩、server推送、server暗示等功能，为了减少使用spdy的协商过程，SPDY规定，协商过程放到SSL协商过程中，从而避免增加延时。</p>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>由于SPDY的诞生和表现，催生了HTTP2.0的诞生。HTTP2.0最大的特点：不会改动HTTP的语义、方法、状态码、URI 及首部字段等。却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量，其核心在于新增的二进制分帧层。</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>由于cookie和user agent以及其他明文传输的头部，很容易让头部膨胀，增大了不必要的传输，所以HTTP2.0对头部进行了压缩。实现的方法为：通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的数据的大小。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在HTTP2.0中，多个请求和响应共用一个tcp通道。一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面。同时，每个stream都可以设置优先级和依赖，以保证优先级高的stream被优先处理。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2允许服务端针对客户端一个单独的请求，主动的发送(或推送)一个或者多个相关的响应。服务端推送语义上等同于服务端响应一个请求；然而，这种情况下请求也是由服务端发送的，作为一个PUSH_PROMISE帧。</p>
<p>相关资源：<br><a href="https://www.rfc-editor.org/rfc/rfc1945.txt" target="_blank" rel="external">HTTP1.0 RFC</a><br><a href="https://www.rfc-editor.org/rfc/rfc2616.txt" target="_blank" rel="external">HTTP1.1 RFC</a><br><a href="https://www.rfc-editor.org/rfc/rfc7540.txt" target="_blank" rel="external">HTTP2.0 RFC</a><br><a href="https://segmentfault.com/a/1190000004399183" target="_blank" rel="external">HTTP2.0那些事</a><br><a href="https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88%2806-29%29.md" target="_blank" rel="external">HTTP2.0 中英文对照</a><br>《图解HTTP》 上野宣 著 于均良 译</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/16/HTTP/" data-id="cioazeloe0010ycq9g2edmqr8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机基础/">计算机基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/OOP/" class="article-date">
  <time datetime="2016-05-03T12:39:17.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/软件开发基础/">软件开发基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/OOP/">面向对象基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对象、类、实例"><a href="#对象、类、实例" class="headerlink" title="对象、类、实例"></a>对象、类、实例</h2><p>一起事物皆为对象，对象是一个自包含的实体，用一组可识别的特性和行为来标识。类就是具有相同的属性和功能的对象的抽象的集合，可以认为类是创建某一类对象的模板。实例是根据类实现的一个真实的对象，实现的过程称为实例化。</p>
<h2 id="构造方法与方法重载（overload）"><a href="#构造方法与方法重载（overload）" class="headerlink" title="构造方法与方法重载（overload）"></a>构造方法与方法重载（overload）</h2><p>构造方法又叫构造函数，其实就是对类进行初始化。根据参数的不同，可以由多种构造方法，方法重载提供了创建同名的多个方法的能力（参数不同）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">string</span> name = <span class="string">""</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h2><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>类的访问修饰符只有public、abstract等，不能使用private、protected等修饰符。属性和方法都有访问修饰符，常见的修饰符有（C#）：</p>
<ul>
<li>private 私有，只允许本类中的成员访问，子类、实例不能访问；</li>
<li>protected 保护访问， 允许本类、子类访问，实例不能访问；</li>
<li>internal 内部访问，指向本项目内访问，其他项目不能访问；</li>
<li>public 共有访问，不受任何限制；</li>
</ul>
<h4 id="set、get访问器"><a href="#set、get访问器" class="headerlink" title="set、get访问器"></a>set、get访问器</h4><p>属性有两个方法get、set。get访问器返回与声明的属性相同的数据类型；set访问器有一个隐式参数，用关键字value表示，进行赋值。使用构造器的好处有控制读写(是否可读、可写、对值的范围进行控制等)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ShouNum</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123; <span class="keyword">return</span> shouNum; &#125;</span><br><span class="line">	<span class="keyword">set</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">value</span>&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">			shouNum = <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装。适当的封装，可以将对象使用接口的程序实现部分隐藏起来，同时确保用户无法任意更改对象内部的重要的数据。封装有这两层的概念，指的是方法的实现。使用封装的好处有：减少耦合、类内部实现可以自由修改、类具有清晰的对外接口。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承定义了类如何相互关联，共享特性。子类（派生类）不但继承了父类（基类）的所有特性，还可以定义新的特性。继承的特性有：</p>
<ul>
<li>子类拥有父类非private的属性和功能；</li>
<li>子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；</li>
<li>子类还可以以自己的方式实现父类的功能（方法重写）；</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//对于构造方法，不能被继承，只能被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function">pulic <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态（override）"><a href="#多态（override）" class="headerlink" title="多态（override）"></a>多态（override）</h4><p>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。<br>在C#中，多态的实现方法为：父类通过virtual关键词，将成员声明为虚拟的，表示这个方法/属性可以被重写；然后，子类可以选择使用override关键字，来重写方法。不同的语言实现多态的方法有差别。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//在C#中，要声明为虚函数，才可以重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 ... <span class="comment">//重写的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。如果行为跨越不同类的对象，可使用接口，对于一些相似的类对象，用继承抽象类。从设计角度看，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。<br>抽象类和接口还有一些其他的具体的区别：</p>
<ul>
<li>抽象类可以给出一些成员的实现，接口却不包含成员的实现。</li>
<li>抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现。</li>
<li>一个类只能继承一个抽象类，但可以实现多个接口等</li>
</ul>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类不能实例化，只是类的抽象</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> getShoutSound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口，应该是现有接口，再由类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing);<span class="comment">//此为继承接口的类要实现的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MachineCat</span>:<span class="title">Cat</span>,<span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing) <span class="comment">//不需要override</span></span><br><span class="line">	&#123; <span class="comment">//方法的实现 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合和泛型"><a href="#集合和泛型" class="headerlink" title="集合和泛型"></a>集合和泛型</h2><p>集合ArrayList是使用大小可按需动态增加的数组，可以通过泛型为其制定集合中的类型。泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、接口、接口和方法所存储和使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作为它所存储的对象的类型的占位符。使用方法如: List<animal> arrayAnimal。</animal></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/OOP/" data-id="cioazelpn002bycq9338pmzkw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WebApp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/WebApp/" class="article-date">
  <time datetime="2016-04-23T08:46:13.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/WebApp/">Web应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>所谓Web应用，指的是使用web技术构建的业务繁杂、逻辑较多、交互频繁的单页Web应用，它在一个界面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面。它是Ajax技术的进一步升华，把Ajax的无刷新机制发挥到极致，因此能早就与桌面程序媲美的流畅用户体验。</p>
<h2 id="Web应用需要解决的问题"><a href="#Web应用需要解决的问题" class="headerlink" title="Web应用需要解决的问题"></a>Web应用需要解决的问题</h2><p>根据徐飞前辈的分类，Web应用中要解决的问题分为三类：状态、组织、效率。<a href="http://www.zhihu.com/question/39943474" target="_blank" rel="external">原文</a></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>在一个业务界面中，我们可能会根据某些数据去生成一块界面，然后根据界面上的某些操作，改变一些数据，进而影响界面另外一部分。所以抽象出来就有两种关系：数据改变造成界面改变、界面改变造成数据改变。能够描述界面当前状态的数据，就称为状态。如果不对状态进行抽象，则可能造成逻辑的混乱，所以，不同的框架采用不同的方式进行了处理。</p>
<h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>所谓组织，指两个方面，一方面是模块关系，一方面是业务模型。<br>目前解决模块关系的问题的共识是组件化。整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。最原始的组件，其功能可以单独开发测试，然后逐级拼装成更复杂的组件，直到整个应用。每一级都是易装配，可追踪，可管控的。组件化的目标有分治和复用，其中分治的价值更大。由于组件设计需要更高的成本和更高的难度，所以对web应用“全组件化”是有一定的难度的，可综合考虑。<br>所谓业务模型指的是所处领域中的业务数据、规则、流程的集合。目前解决业务模型的方法有flux、redux之类的架构。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>效率分为开发效率和运行效率。开发效率与选用的框架、技术以及组件化等都有很大的关系。运行效率主要因素有数据变更检测方式和创建、修改DOM。数据变更检测方式和框架有很大的关系，创建DOM的过程中，各个框架之间没有太大差异，而在修改DOM的时候，React的虚拟DOM有很大的优秀，其他框架内部实现也在逐渐借鉴。</p>
<h2 id="常见的架构"><a href="#常见的架构" class="headerlink" title="常见的架构"></a>常见的架构</h2><p>目前在Web应用中，常用的架构有MVC、MVP、MVVM三种。下面这两篇文章讲的很好。<br><a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" target="_blank" rel="external">Scaling Isomorphic Javascript Code</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></p>
<h2 id="开发框架与类库"><a href="#开发框架与类库" class="headerlink" title="开发框架与类库"></a>开发框架与类库</h2><p>通常，我们会开始用类库和框架来解决构建动态应用的问题。类库是一些函数的集合，它可以帮助我们写Web应用，但起主导作用的是我们的代码，如jQuery。而框架是一种特殊的、已经实现了的Web应用，它只需要填充具体的业务逻辑，其主导作用的是框架。</p>
<ul>
<li>ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成前端的开发以及布局。然而，随着功能的逐渐增加，ExtJS的体积变得日益庞大，性能也变得越来越差。</li>
<li>React可以认为是MVC中的V视图，其产生的意义是：解决构建随时间数据不断变化的大规模应用程序的问题。其主要特点是组件化（也可以使用其独有的jsx）和虚拟DOM树（只会更新需要更新的DOM，节省大量的DOM修改的时间）。React推崇的是单向数据流：给定原始界面，施加一个变化，就可以推导出顶一个状态（界面或数据的更新）</li>
<li>Angular是为了克服HTML在构建应用上的不足而设计的。它采用了MVVM的架构，采用了数据与界面的双向数据绑定，当界面发生变化时，按照配置规则去更新相应的数据，然后，在根据配置好的规则，把数据更新到界面状态。</li>
<li>Vue是一个构建数据驱动的web界面的库。Vue.js的目标是通过尽可能简单的API实现相应的数据绑定和组合的视图组件。它只聚焦于视图层，非常容易与其他库或已有项目整合。其核心是一个响应的数据绑定系统，它让数据与DOM保持同步变得非常简单。<a href="http://cn.vuejs.org/guide/comparison.html" target="_blank" rel="external">与其他框架的对比</a></li>
<li>jQuery是一个优秀的JavaScript库，它是轻量级的js库，兼容CSS3以及各种浏览器。jQuery是用户能更方便地处理HTML、events、实现动画效果和AJAX交互。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/WebApp/" data-id="cioazelps002jycq9q2ut9b8w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flexbox" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/flexbox/" class="article-date">
  <time datetime="2016-04-23T05:26:23.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/flexbox/">flexbox</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文大量参考了Helen Emerson的<a href="http://helephant.com/2013/03/23/css3-flexbox-layout/" target="_blank" rel="external">《Using the CSS3 flexbox layout》</a>，如有需要，请移步此文。</p>
<h2 id="Flexbox简述"><a href="#Flexbox简述" class="headerlink" title="Flexbox简述"></a>Flexbox简述</h2><p>Flexbox的布局是一个用于页面布局的CSS3模块，目前为止，大部分的浏览器都支持或部分支持此功能，支持情况请参考<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">caniuse网站</a>。Flexbox可以简单快速的创建一个具有弹性功能的布局，当在一个小屏幕上显示的时候，Flexbox可以让元素在伸缩容器中进行自由扩展和收缩，从而调整整个布局。</p>
<h2 id="伸缩容器和伸缩项目"><a href="#伸缩容器和伸缩项目" class="headerlink" title="伸缩容器和伸缩项目"></a>伸缩容器和伸缩项目</h2><p>一个flexbox布局由伸缩容器和其中的伸缩项目组成。伸缩容器是一个HTML标签元素，并且“display”属性显示设置“flex”属性值，伸缩容器中的所有子元素都会自动变成伸缩项目（flex items）。</p>
<h2 id="伸缩方向与换行（flex-flow）"><a href="#伸缩方向与换行（flex-flow）" class="headerlink" title="伸缩方向与换行（flex-flow）"></a>伸缩方向与换行（flex-flow）</h2><p>伸缩容器有一个CSS属性“flex-flow”用来决定伸缩项目的布局方式。常见的flex-flow的值有row、column、row wrap等，其伸缩项目排列方式如下：</p>
<p><img src="/img/CSS3/flexflow-row.png" alt="flex-flow:row"><br><img src="/img/CSS3/flex-flow-column.png" alt="flex-flow:column"><br><img src="img/CSS3/flexbox-rowwrap.png" alt="flex-flow:row wrap"></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row; <span class="comment">//还有columen、warp、row warp等</span></span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">1000px</span>; <span class="comment">//还可以使用max-widht等属性设置最大/最小宽度/高度等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伸缩项目设置"><a href="#伸缩项目设置" class="headerlink" title="伸缩项目设置"></a>伸缩项目设置</h2><p>伸缩容器中的所有子元素都将自动变成伸缩项目，仅需要设置伸缩项目的尺寸即可。设置其尺寸可以使用widht、height等固定伸缩项目的宽和高，也可以使用flex属性（还可以结合min-widht等属性）动态改变伸缩项目的尺寸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row wrap；</span><br><span class="line">	max-width: <span class="number">1500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-widht</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">	<span class="attribute">min-widht</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSS3/flex-item-width.png" alt=""><br>在以上容器中，为left right都设置flex，最小/最大宽度，而mian设置了固定宽600px。其排列规则如下（在chrome中验证）：</p>
<ol>
<li>当宽度足够宽时，先去除main的600px固定宽，left和right宽度比为1:2（超过max-widht，长度自动设为max-width的值）。</li>
<li>当宽度不足时，优先满足left的min-widht和mian的widht。如果无法满足right的min-widht，right转到第二行。一次类推。</li>
<li>所以，可以结合min-widht、max-widht和flex动态调整元素大小，并使元素不至于过大或者过小。</li>
<li>计算规则为先按照flex分配元素尺寸（如果只有一个flex，则其填充剩余空白），然后参考最大最小尺寸，确定元素尺寸。每个元素都自动有一个隐式的最小尺寸，这里需要注意一下。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/flexbox/" data-id="cioazelqa0031ycq9f4dyi921" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/react-learn/" class="article-date">
  <time datetime="2016-04-17T13:13:55.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/react-learn/">react初步认识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React起源于Facebook的内部项目，其设计思想及其独特，属于革命性创新，性能出众，代码逻辑简单。其主要优点有：</p>
<ol>
<li>虚拟DOM，在必要的时候才将组件渲染到真正的DOM上，减少频繁的DOM操作造成的性能问题。</li>
<li>组件化，React都是关于构建可复用的组件。事实上，通过React唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离更加简单。</li>
</ol>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
    &lt;script src=&quot;http://fb.me/react-0.13.0.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;http://fb.me/JSXTransformer-0.13.0.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/jsx&quot;&gt;
      var HelloWorld = React.createClass({
          render: function() {
            return (
                  &lt;p&gt;
                    Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot; /&gt;!
                    It is {this.props.date.toTimeString()}
                  &lt;/p&gt;
            );
          }
        });

        setInterval(function() {
              React.render(
                &lt;HelloWorld date={new Date()} /&gt;,
                document.getElementById(&apos;example&apos;)
              );
        }, 500);

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>React提供了一个官方例子<a href="http://reactjs.cn/react/blog/2013/11/05/thinking-in-react.html" target="_blank" rel="external">英文</a><a href="http://reactjs.cn/react/docs/thinking-in-react.html" target="_blank" rel="external">中文</a>，从如何拆分组件树、如何利用React创建静态版本、如何识别最小的state、如何确认state的声明周期到添加方向数据流，较完整的展现了react的应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/17/react-learn/" data-id="cioazelqt003mycq9pwcgvg5p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-async" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-async/" class="article-date">
  <time datetime="2016-04-14T19:25:50.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-async/">ECMAScript6中的异步操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>Generator函数是ES6提供的一种异步编程解决方案，我们可以将Generator函数理解成一个状态机，执行这个函数会返回一个遍历器对象。Generator函数内部使用yield语句，没执行一次函数的next方法，执行到下一个yield，直到函数结束，从而达到异步调用函数的目的。此外，yield本身没有返回值，next方法可以带一个参数，该参数将被当做上一个yield语句的返回值，实现在generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般与for of结合的使用方法，不需要使用next方法</span></span><br><span class="line"><span class="built_in">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="built_in">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);  <span class="comment">//在generator函数中调用另一个generator函数，要使用yield*</span></span><br><span class="line">    &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125; <span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过next函数注入不同的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; 5+24+13=42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数的改写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> loader = loadUI();</span><br><span class="line"></span><br><span class="line">loader.next();<span class="comment">// 加载UI</span></span><br><span class="line">loader.next(); <span class="comment">//// 卸载UI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部署Ajax操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="built_in">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response); <span class="comment">//将response作为值传入</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">//执行request操作</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。Promise独享的状态（pending、resolved、rejected）不受外界影响，只有异步操作的结果可以决定当前是哪一种状态。一旦状态发生改变，就不再变。如果某些事件不断反复发生，一般阿狸说，使用stream模式比部署Promise更好。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line"><span class="built_in">var</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">//接收一个函数，函数有两个参数</span></span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">//接收两个函数，分别在成功和失败的时候执行</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步加载图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + <span class="built_in">url</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = <span class="built_in">url</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//generator和promise的结合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="decorator"><span class="keyword">try</span></span> &#123;</span><br><span class="line">    <span class="built_in">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h2 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h2><p>ES6之前，异步编程的方法，大概有：回调函数、事件监听、发布/订阅、Promise对象，ES6则应用generator函数是异步编程进入全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="comment">//1.回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise</span></span><br><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); <span class="comment">//读入A后，读取B，则会出现多重嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.协程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.generator</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.Async</span></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>); <span class="comment">//await表示紧跟后面的表达式需要等待结果</span></span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>); <span class="comment">//返回Promise对象，如果不是，则转为promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-async/" data-id="cioazelnr000bycq9zni1v4iz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-class/" class="article-date">
  <time datetime="2016-04-14T19:24:56.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-class/">ECMAScript6中的Class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本质上，ES6只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性，Class和let一样，不存在变量提升。ES6实现了类的继承，类的静态方法，但是目前没有规定类的静态属性，在ES7中，有关于静态属性的提议。</p>
<h2 id="Class类基础"><a href="#Class类基础" class="headerlink" title="Class类基础"></a>Class类基础</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line">Class  Point &#123; <span class="comment">//其实它可以看做构造函数的另一种写法。</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x; <span class="comment">//显示定义在本身，而不是原型上</span></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; <span class="comment">//class这种写法，方法是不可枚举的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>Class之间可以通过extends关键字实现继承。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">//this是继承父类的this对象，然后对其进行加工</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// super代表父类实例，调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的prototype和proto属性"><a href="#类的prototype和proto属性" class="headerlink" title="类的prototype和proto属性"></a>类的prototype和<em>proto</em>属性</h2><p>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。一、子类的<em>proto</em>属性，表示构造函数的继承，总是指向父类。二、子类prototype属性的<em>proto</em>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。父类的静态方法，可以被子类继承。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod() <span class="comment">//typeeror static方法不会被实例继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> super.classMethod()+<span class="string">'too'</span>; <span class="comment">//可以从super对象上调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod() <span class="comment">//'hello' static方法可以被子类继承，</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-class/" data-id="cioazelnz000gycq9kh2exle1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-iterator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6-iterator/" class="article-date">
  <time datetime="2016-04-14T13:28:33.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6-iterator/">ECMAScript6新属性方法等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6中添加了一些新的结构、属性、方法等，下面将进行简单的说明。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES5的对昂属性名都是字符串，容易造成属性名的冲突。ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，它是JavaScript的第七种数据类型，通过Symbol函数生成。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'Hello!'</span>&#125;; <span class="comment">//symbol属性不能使用.运算符</span></span><br><span class="line">a[mySymbol] <span class="comment">//"Hello!" symbol属性不能使用.运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>); <span class="comment">//必须都是用for，且输入值相同，才相等</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 == s2  <span class="comment">//true 使用symbol.for可以实现两个symbol相同</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">//"foo" sysmol.for()有登记制，symbol()没有，登记的会返回字符串参数</span></span><br></pre></td></tr></table></figure>
<h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h4 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h4><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set的方法有四个：set.add(value)、set.delete(value)、set.has(value)、set.clear()清除所有成员。如果要读取或者遍历可以将set通过Array.from(set)转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">"4"</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>]);</span><br><span class="line">alert(set.size); <span class="comment">//6 在set内部，4不等于“4”（不会发生类型转换），NaN等于NaN，对象总是不等于对象&#123;&#125;不等于&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>)</span>&#123; <span class="comment">//数组去重的方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet与Set类似，也是不重复的值的集合，但是它与Set有两个区别。一、WeakSet的成员只能是对象。二、WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]; <span class="comment">//数组的成员只能是对象，不能是变量</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br></pre></td></tr></table></figure>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。ES6提供了Map数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键，是一种更完善的Hash结构实现。<br>Map原生提供三个遍历器生成函数和一个遍历方法。entries()、keys()、values()、forEach()。<br>Map可以与数组、对象、Json相互转换。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">m</span> = new Map();</span><br><span class="line"><span class="keyword">var</span> o = &#123;p:<span class="string">"hello tecent"</span>&#125;;</span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">set</span>(o,<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">m</span>.<span class="built_in">get</span>(o); <span class="comment">//"content"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">m</span>.size <span class="comment">//1</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.delete(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">clear</span>(); <span class="comment">//全部清空</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap与Map结构基本类似，唯一的区别是它只接受对象做为键名(null除外)，而且键名所指向的对象，不计入垃圾回收机制。其设计目的在于，键名是对象的弱引用。</p>
<h2 id="Iterator遍历器与for…of循环"><a href="#Iterator遍历器与for…of循环" class="headerlink" title="Iterator遍历器与for…of循环"></a>Iterator遍历器与for…of循环</h2><p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。其遍历过程如下：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象（字符串等）、Set和Map结构。另外，也可以手动为对象等添加Iterator接口。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = ['a', 'b'];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="type">Symbol</span>.<span class="keyword">iterator</span>](); //默认的<span class="type">Iterator</span>接口部署在数据结构的<span class="type">Symbol</span>.<span class="keyword">iterator</span>属性</span><br><span class="line">iter.next() // &#123; value: 'a', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: 'b', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr =['b','c'];</span><br><span class="line">['a',…arr,'d'] //['a','b','c','d'] 扩展运算符会调用默认的<span class="keyword">iterator</span>接口</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = ['a', 'b', 'c', 'd'];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">in</span>循环，只获得对象的键名</span><br><span class="line">  console.log(a); // <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">of</span>循环，获得对象的键值，只返回具有数字索引的属性</span><br><span class="line">  console.log(a); // a b c d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = new <span class="type">Map</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [name,value] <span class="keyword">of</span> map)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6-iterator/" data-id="cioazelo3000jycq9g729r1vo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6/" class="article-date">
  <time datetime="2016-04-14T07:35:01.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6/">ECMAScript6为数据类型添加的新方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6在2015年6月正式发布。它的目标，是是的JavaScript语言可以用来编写复杂的大型应用陈旭，称为企业级开发语言。ECMAScript是JavaScript的规格，后者有时前者的一种实现。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><p>ES6新增let命令，用来声明变量，用法类似于var。区别为：</p>
<ul>
<li>let所声明的变量，只在let命令所在的代码块内有效。</li>
<li>let不存在“变量提升”现象，即其变量的定义是在JavaScript的代码执行阶段。</li>
<li>let存在暂时性死区，即又要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。</li>
<li>let实际上为JavaScript新增了块级作用域；<br>如此便解决了块级局部变量以及for循环中局部变量的问题。解决了如下一个大问题：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">//i为局部变量，</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">5</span>](); <span class="comment">//5，每次的i都是一个新的变量</span></span><br></pre></td></tr></table></figure>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p>const用来定义常量，一旦声明，常量的值就不能改变。</p>
<ul>
<li>严格模式下，重新赋值会报错，常规模式下，赋值无效不报错；</li>
<li>const声明时不赋值则不能赋值，常量为undefind。严格模式下，const声明时必须赋值，否则报错；</li>
<li>const存在块级作用域。</li>
</ul>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。可以用于交换变量的值、从函数返回多个值、函数参数定义、解析jsondata等。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]]; </span><br><span class="line">bar <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>]; <span class="comment">//a=1,b=undefined</span></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//解构不完全，但可以成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认值</span></span><br><span class="line"><span class="keyword">var</span> [c=<span class="number">1</span>,d=<span class="number">2</span>,e=<span class="number">3</span>] = [<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="number">5</span>]; <span class="comment">//1,null,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用途</span></span><br><span class="line">[x,y] = [y,x]; <span class="comment">//交换变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a,b,c] = example(); <span class="comment">//从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x,y,z])</span></span>&#123;……&#125;</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">//函数参数定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析jsondata等</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>String类型主要添加了遍历字符、字符串的头尾判断、字符串重复、字符的有关Unicode表示等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(codePoint); <span class="comment">//分别显示 f o o ，遍历字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s=<span class="string">'Hello world'</span>;</span><br><span class="line">s.startWith(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line">s.endWith(<span class="string">'Hello'</span>,<span class="number">5</span>); <span class="comment">//true,可以添加第二个参数，表示搜索的位置。</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>); <span class="comment">//"hellohello"</span></span><br></pre></td></tr></table></figure>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>新增了是否为无穷、NaN判断，是否为整数，安全整数，另外，parseInt()、parseFloat()方法也放到了Number对象的下面。Math对象的话则添加了获取整数部分，返回正负值，立方根、对数等。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> // <span class="number">0b</span>二进制 <span class="literal">true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> // <span class="number">0o</span>八进制 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Number.isFinite(<span class="number">0.8</span>); //<span class="literal">true</span> 是否为非无穷,检查Infinate特殊值</span><br><span class="line">Number.isNaN(NaN); //<span class="literal">true</span> 是否为NaN，检查NaN特殊值</span><br><span class="line"></span><br><span class="line">Number.parseInt('<span class="number">12.34</span>'); //<span class="number">12</span> 将全局方法parseInt()、parseFloat()，移植到Number对象上</span><br><span class="line">Number.parseFloat('<span class="number">12.45</span>#'); //<span class="number">12.45</span></span><br><span class="line"></span><br><span class="line">Number.isInteger(<span class="number">3.0</span>); //<span class="literal">true</span> 是否为整数，JavaScript中，整数和浮点数使用同样的存储方法，所以<span class="number">3</span>和<span class="number">3.0</span>视为一个值</span><br><span class="line">Number.isSafeInteger(Math(<span class="number">2</span>,<span class="number">53</span>)-<span class="number">1</span>); /<span class="literal">true</span>，JavaScript能够精确表示-<span class="number">2</span>^<span class="number">53</span>到-<span class="number">2</span>^<span class="number">53</span>间的整数（不含端点），超过则无法精确表示这个值</span><br><span class="line"></span><br><span class="line">Math.<span class="built_in">trunc</span>(<span class="number">4.1</span>); //<span class="number">4</span> 用于取出一个数的小数部分，返回整数部分</span><br><span class="line">Math.<span class="built_in">sign</span>(-<span class="number">5</span>); //-<span class="number">1</span> 参数为正数返回+<span class="number">1</span> 其他返回+<span class="number">0</span>、<span class="number">0</span>、+<span class="number">0</span>、-<span class="number">1</span>和NaN</span><br><span class="line">Math.cbrt(<span class="number">2</span>); //<span class="number">1.2599210498948734</span> 返回一个数的立方根</span><br><span class="line"></span><br><span class="line">//还有对数方法、关于<span class="number">32</span>位无符号数的方法等</span><br></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>新增了将类数组转换为数组、将一组值转换为数组的方法，通过find()查找第一个符合条件的数组成员，通过fill填充数组，还可以通过entries()等方法返回键值对数组等。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike=&#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="string">'2'</span>:<span class="string">'c'</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line">var arr1 = [].slice.call(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES5</span>的方法</span><br><span class="line">let arr2 = <span class="symbol">Array</span>.from(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES6</span>的方法</span><br><span class="line"><span class="symbol">Array</span>.from(<span class="string">'abcde'</span>); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br><span class="line"><span class="symbol">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x); //[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>] 接收第二个参数，对每个元素进行处理</span><br><span class="line"></span><br><span class="line"><span class="symbol">Array</span>.of(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>); //[<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>] 将一组值，转换为数组，主要目的是弥补数组构造函数<span class="symbol">Array</span>()的不足</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find((n) =&gt; n&lt;<span class="number">0</span>); //<span class="number">-5</span> 用于找出第一个符合条件的数组成员</span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>); //[<span class="string">'a'</span>,<span class="number">7</span>,<span class="string">'c'</span>] 第一个参数表示填充值，剩下两个表示填充起始位置和结束位置</span><br><span class="line"></span><br><span class="line">//entries() keys() values()用于遍历数组，分别表示遍历键值对、键、值</span><br><span class="line">for(let [index,elem] of [<span class="string">'a'</span>,<span class="string">'b'</span>].entries())&#123;</span><br><span class="line">	console.log(index,elem);</span><br><span class="line">&#125; //<span class="number">0</span> <span class="string">"a"</span>   <span class="number">1</span>  <span class="string">"b"</span> </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>); //true 是否包含给定数值</span><br></pre></td></tr></table></figure>
<h2 id="函数参数的扩展"><a href="#函数参数的扩展" class="headerlink" title="函数参数的扩展"></a>函数参数的扩展</h2><p>函数中新增了设置参数默认值、rest参数等功能，并且新增了箭头函数，尾递归优化等，并且可以通过函数的length属性获取其无默认值参数的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = 0, y = 0</span>) </span>&#123; <span class="comment">//设置参数默认值</span></span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">5</span>); <span class="comment">//p.x=5,p.y=0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常定义了默认值的参数，应该是函数的尾参数，因为输入f(,)这种没有赋值的函数会出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y=1</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [x,y];</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">//[2,1] 这样就可以省略尾部的有默认值的参数</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=1</span>)</span>&#123;&#125;&#125;).length <span class="comment">//2 返回没有指定默认值的参数个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定参数是否可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//会抛出错误，因为mustBeProvided默认值为抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量数量不定，rest参数。values变量表示一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">var</span> f = v =&gt; v*v; <span class="comment">//f(2)等于4</span></span><br><span class="line"><span class="keyword">var</span> sum = (num1,num2) =&gt; num1+num2 <span class="comment">//等同于下面</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1,num2</span>)</span>&#123; <span class="keyword">return</span> num1+num2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，只保留一个调用记录（严格模式下开启），复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>对象的扩展对象合并、属性遍历、返回对象键值数组等</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">//true 只要两个值一样，就相等，不同于===</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">"12"</span>,<span class="number">12</span>) <span class="comment">//false 不进行自动转换类型，不同于==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象合并，常用于为对象添加属性和方法以及克隆对象等</span></span><br><span class="line"><span class="built_in">var</span> target = &#123; <span class="attribute">a</span>: <span class="number">1</span>, <span class="attribute">b</span>: <span class="number">1</span> &#125;; <span class="comment">//合并对象，只是浅复制</span></span><br><span class="line"><span class="built_in">var</span> source1 = &#123; <span class="attribute">b</span>: <span class="number">2</span>, <span class="attribute">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1); <span class="comment">//&#123; a:1, b: 2, c: 2&#125;将后面的对象都复制到第一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的遍历</span></span><br><span class="line"><span class="keyword">for</span>……<span class="keyword">in</span> <span class="comment">//遍历对象自身和继承的可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)  <span class="comment">//返回一个数组，包含对象自身（不含继承的）所有可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)  <span class="comment">//返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象的键值对数组、键数组和值数组</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">//返回obj对象的值数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">//返回obj对象的键数组</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">//[["a","1"],["b",2]] 返回obj对象的值数组</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6/" data-id="cioazelo6000nycq9z0szbb9n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript-crossOrigin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/JavaScript-crossOrigin/" class="article-date">
  <time datetime="2016-04-11T04:38:02.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/JavaScript-crossOrigin/">跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>跨域是JavaScript开发中的重要的概念，跨域是打破同源策略的限制实现跨域资源访问的技术手段。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也是最基本的安全功能。所谓同源是指协议、域名、端口相同，同源策略即为JavaScript文件只能访问包含它的页面所在的域的资源。此外，通过&lt; script&gt;标签等引入的JavaScript、CSS、图像等静态资源也被认为是与包含它们的界面所在的域同源。</p>
<p>在页面中，&lt; script&gt;&lt; img&gt;&lt; link&gt;&lt; iframe&gt;标签不受同源策略的影响，可以访问其他域的内容。</p>
<h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><p>跨域资源共享是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同域访问其资源。而这种访问是同源策略所禁止的。它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。跨域资源共享的基本思想，是通过自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是否应该成功。<br>默认情况下，XHR对象只能访问与包含它的页面位于同一域中的资源，所以通过xhr.open()打开的是相对路径的url，如果浏览器支持CORS，则可以将url设置为指向其他域资源的绝对路径的url。将请求发送给服务器后，服务器会根据这个头部信息决定是否给予响应，可以接受的话，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回*），如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。<br>与JSONP相比，CORS无疑更加先进：</p>
<ol>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，开发者可以使用普通的xhr对象发起请求和获得数据，比起JSONP有更好的错误处理。</li>
</ol>
<h4 id="xhr与xdr"><a href="#xhr与xdr" class="headerlink" title="xhr与xdr"></a>xhr与xdr</h4><p>微软在IE8中引入了XDR类型，这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。XHR实现Ajax通信的一个主要限制，则来源于跨域安全策略，通过CORS，则可以突破其同源策略限制。xdr与xhr的不同之处有：</p>
<ul>
<li>cookie不会随请求发送，也不会随响应返回。</li>
<li>只能设置请求头部信息中的Content-Type字段</li>
<li>不能访问相应头部信息。</li>
<li>只支持GET和POST请求。</li>
</ul>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP是JSON with padding的简写，是应有JSON的一种方法。JSONP由两部分组成：回调函数和数据。回调函数是当相应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。JSONP是通过动态&lt; script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//客户端</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"divCustomers"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callbackFunction</span>(<span class="params">result, methodName</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> html = <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                html += <span class="string">'&lt;li&gt;'</span> + result[i] + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            html += <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'divCustomers'</span>).innerHTML = html;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//服务器端</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-type: application/json'</span>);</span><br><span class="line"><span class="comment">//获取回调函数名</span></span><br><span class="line">$jsoncallback = htmlspecialchars($_REQUEST [<span class="string">'jsoncallback'</span>]);</span><br><span class="line"><span class="comment">//json数据</span></span><br><span class="line">$json_data = <span class="string">'["customername1","customername2"]'</span>;</span><br><span class="line"><span class="comment">//输出jsonp格式的数据</span></span><br><span class="line"><span class="keyword">echo</span> $jsoncallback . <span class="string">"("</span> . $json_data . <span class="string">")"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="document-domain设置跨子域"><a href="#document-domain设置跨子域" class="headerlink" title="document.domain设置跨子域"></a>document.domain设置跨子域</h2><p>主域相同而子域不同的情况下，可以通过设置document.domain来实现跨域。但是使用document.domain来设置域名是有限制的，比如a.b.example.com某个文档中的域名可以设成a.b.example.com/b.example.com/example.com。使用方法如下：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//www.a.com上的a.html</span></span><br><span class="line">document.domain = <span class="string">'a.com'</span><span class="comment">;</span></span><br><span class="line">var ifr = document.createElement(<span class="string">'iframe'</span>)<span class="comment">;</span></span><br><span class="line">ifr.src = <span class="string">'http://script.a.com/b.html'</span><span class="comment">;</span></span><br><span class="line">ifr.style.display = <span class="string">'none'</span><span class="comment">;</span></span><br><span class="line">document.body.appendChild(ifr)<span class="comment">;</span></span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">    var doc = ifr.contentDocument || ifr.contentWindow.document<span class="comment">;</span></span><br><span class="line">    <span class="comment">// 在这里操纵b.html</span></span><br><span class="line">    alert(doc.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//script.a.com上的b.html</span></span><br><span class="line">document.domain = <span class="string">"a.com"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h2><p>Web Sockets的目标是在一个单独的持久连接上提供双工、双向通信。使用标准的HTTP服务器无法实现Web Sockets，只要支持这种协议的专门服务器才能正常工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket=<span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">socket.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> data = event.data;</span><br><span class="line">	<span class="comment">//处理数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><ul>
<li>Commet：指一种更高级的Ajax技术，也被称为服务器推送技术。是一种服务器向页面推送数据的技术，能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价等。</li>
<li>图像Ping，利用&lt; img&gt;标签不受同源限制的性质。通过它，浏览器得不到任何具体的数据，但通过监听load和error事件，它能知道响应是什么时候收到的。常用于跟踪用户点击页面或动态广告曝光次数。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/11/JavaScript-crossOrigin/" data-id="cioazelpd0024ycq9rzwg0311" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域/">跨域</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ExtJS/">ExtJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端框架/">前端框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发基础/">软件开发基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Language/">C-Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C语言/">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExtJS/">ExtJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发/">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端框架/">前端框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机基础/">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ajax/" style="font-size: 11.67px;">Ajax</a> <a href="/tags/C-Language/" style="font-size: 10px;">C-Language</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/C语言/" style="font-size: 11.67px;">C语言</a> <a href="/tags/ExtJS/" style="font-size: 13.33px;">ExtJS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 18.33px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TCP-IP/" style="font-size: 11.67px;">TCP/IP</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/前端开发/" style="font-size: 20px;">前端开发</a> <a href="/tags/前端开发，CSS3/" style="font-size: 10px;">前端开发，CSS3</a> <a href="/tags/前端框架/" style="font-size: 11.67px;">前端框架</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/计算机基础/" style="font-size: 16.67px;">计算机基础</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/软件开发基础/" style="font-size: 10px;">软件开发基础</a> <a href="/tags/链接集/" style="font-size: 10px;">链接集</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/16/HTTP/">HTTP协议</a>
          </li>
        
          <li>
            <a href="/2016/05/03/OOP/">面向对象基础概念</a>
          </li>
        
          <li>
            <a href="/2016/04/23/WebApp/">Web应用</a>
          </li>
        
          <li>
            <a href="/2016/04/23/flexbox/">flexbox</a>
          </li>
        
          <li>
            <a href="/2016/04/17/react-learn/">react初步认识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Rancho<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>