<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>步步为营，勇往直前</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="步步为营，勇往直前">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="步步为营，勇往直前">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="步步为营，勇往直前">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="步步为营，勇往直前" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">步步为营，勇往直前</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">赵培霏的学习博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-valueIsEqual" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/26/valueIsEqual/" class="article-date">
  <time datetime="2016-05-26T12:48:44.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/valueIsEqual/">JS中两个值是否相等&amp;类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ES5和ES6中的比较相等的运算符"><a href="#ES5和ES6中的比较相等的运算符" class="headerlink" title="ES5和ES6中的比较相等的运算符"></a>ES5和ES6中的比较相等的运算符</h2><p>在ES5中，只有两个运算符：相等运算符（==）和严格相等运算符（===）。在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-type-conversion" target="_blank" rel="external">ES6</a>中，则新增了一个中比较相等的方法Object.is()。<br>相等运算符会自动转换数据类型，而严格相等运算符不会。但是，根据严格相等运算符，NaN不等于NaN，+0等于-0。<br>ES6的Object.is()提出“Same-value equality”（同值相等）算法，以解决上述问题。其用来比较两个值是否严格相等，与严格比较运算符的行为基本一致。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>进行<br>也可以参考官方版<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-type-conversion" target="_blank" rel="external">类型转换</a></p>
<h3 id="转为String"><a href="#转为String" class="headerlink" title="转为String"></a>转为String</h3><ol>
<li>undefined null true false 均转换为相应的字符串：“undefined”等</li>
<li>数值：+0和-0转为“0”；NaN、Infinity、-Infinity均转换为相应的字符串</li>
<li>对象对有toString()方法，则直接调用。否则，尝试调用valueOf()。否则返回类型错误异常。<br>toString()方法：数组返回逗号隔开的数组字符串；函数可以返回函数的字符串；Date、TegExp也可以返回。普通的object（{x:1,y:2}）返回[object object]。</li>
</ol>
<h3 id="转为Number"><a href="#转为Number" class="headerlink" title="转为Number"></a>转为Number</h3><ol>
<li>undefined转为NaN，null转为+0</li>
<li>true为1，false为0</li>
<li>“”为0；”1.2”转为1.2；”one”转为NaN；其他的看下面具体规则</li>
<li>如果为对象。先转换为原始值，再转换为数值。[]转为0；[9]转为0，其他基本都是NaN；</li>
</ol>
<h3 id="转为Boolean"><a href="#转为Boolean" class="headerlink" title="转为Boolean"></a>转为Boolean</h3><ol>
<li>undefined null “” 0 -0 NaN 转为false</li>
<li>其他的转为true（包括[]、{}） </li>
</ol>
<h2 id="三个方法的比较及结果"><a href="#三个方法的比较及结果" class="headerlink" title="三个方法的比较及结果"></a>三个方法的比较及结果</h2><p>下列的步骤，是有顺序的，如满足1，则不会使用2.</p>
<h3 id="相等比较步骤"><a href="#相等比较步骤" class="headerlink" title="相等比较步骤"></a>相等<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-abstract-equality-comparison" target="_blank" rel="external">比较步骤</a></h3><ol>
<li>如果两个值类型相同，返回严格相等（===）的结果。</li>
<li>null和undefined返回true</li>
<li>一个为Number，一个为String，将String转为Number；</li>
<li>布尔类型转换为Number比较</li>
<li>一个为String/Number/Boolean，另一个为object，则将object转换，进行比较；<br>总结：有Number类型，则将另外一个值<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber" target="_blank" rel="external">转为Number</a>进行比较。Boolean转为Number。一个为object则<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toprimitive" target="_blank" rel="external">转换为原始值</a>进行比较。</li>
</ol>
<h3 id="严格相等比较步骤"><a href="#严格相等比较步骤" class="headerlink" title="严格相等比较步骤"></a>严格相等<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-strict-equality-comparison" target="_blank" rel="external">比较步骤</a></h3><ol>
<li>类型不相同，返回false</li>
<li>null等于null，undefined等于undefined</li>
<li>NaN不等于任何数，包括自身；两个数值相同，返回true；+0等于-0；其他false</li>
<li>为String，完全相等，返回true</li>
<li>true等于true，false等于false；</li>
<li>相同的Symbol值（Symbol.for(‘f’),Symbol.for(‘f’)），返回true；</li>
<li>相同的object，则返回true。</li>
<li>返回false；</li>
</ol>
<h3 id="Object-is-比较步骤"><a href="#Object-is-比较步骤" class="headerlink" title="Object.is()比较步骤"></a>Object.is()<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.is" target="_blank" rel="external">比较步骤</a></h3><ol>
<li>Type(x)和Type(y)不同，返回false</li>
<li>Type(x)为null或undefined，返回true（null等于null，undefined等于undefined）</li>
<li>Type(x)为数字。NaN等于NaN；+0不等-0；相同数字相等；正/负无穷不等于正/负无穷；</li>
<li>Type(x)为string，两个值为相同的序列单元返回true，否则返回false；</li>
<li>Type(x)为Boolean，true等于true，false等于false；</li>
<li>Type(x)为Symbol，相同的Symbol值，返回true；</li>
<li>x和y是相同的object值，返回true，否则返回false（{}不等于{}）。</li>
</ol>
<h3 id="一些特殊值的比较"><a href="#一些特殊值的比较" class="headerlink" title="一些特殊值的比较"></a>一些特殊值的比较</h3><table>
<thead>
<tr>
<th style="text-align:center">值1   值2</th>
<th style="text-align:center">==</th>
<th style="text-align:center">===</th>
<th style="text-align:center">Object.is()</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类型不同</td>
<td style="text-align:center">转换</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">null undefined</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">null null</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">undefined undefined</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">NaN NaN</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">+0  -0</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">-Infinity -Infinity</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">“12345” “12345”</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">false false</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">Symbol(‘f’) Symbol.for(‘f’)</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Symbol.for(‘f’) Symbol.for(‘f’)</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">object object(全等)</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<h2 id="参考链接及书籍"><a href="#参考链接及书籍" class="headerlink" title="参考链接及书籍"></a>参考链接及书籍</h2><p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html" target="_blank" rel="external">ECMAScript2015 官方语法</a><br>JavaScript中文版</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/26/valueIsEqual/" data-id="cioofeu8k004rm4q9iyypi7tp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/16/HTTP/" class="article-date">
  <time datetime="2016-05-16T06:37:38.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/HTTP/">HTTP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP（HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端进行资源请求和应答的标准。</p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><h4 id="get-获取资源"><a href="#get-获取资源" class="headerlink" title="get 获取资源"></a>get 获取资源</h4><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的资源是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。</p>
<h4 id="post-传输实体主体"><a href="#post-传输实体主体" class="headerlink" title="post 传输实体主体"></a>post 传输实体主体</h4><p>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取相应的主体内容。</p>
<h4 id="head-获得报文首部"><a href="#head-获得报文首部" class="headerlink" title="head 获得报文首部"></a>head 获得报文首部</h4><p>HEAD方法与GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>
<h4 id="option-询问支持的方法"><a href="#option-询问支持的方法" class="headerlink" title="option 询问支持的方法"></a>option 询问支持的方法</h4><p>用来查询这对请求URI指定的资源支持的方法。</p>
<h4 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h4><p>参考：<a href="https://segmentfault.com/a/1190000004014583#articleHeader7" target="_blank" rel="external">GET请求和POST请求的区别</a> <a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="external">HTTP方法：GET对比POST</a></p>
<ul>
<li>在HTTP/1.1中，get被强制服务器支持，即服务器必须实现get方法</li>
<li>浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li>
<li>POST请求相对GET请求是相对安全的。因为get请求会将数据添加到url后，普通人都可以看到。而post则需要进行抓包才可以看到。所以说相对安全。</li>
<li>在规范的定义下，GET操作不会修改服务器的数据<br><img src="/img/计算机基础/get和post的区别.png" alt=""></li>
</ul>
<h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><p>HTTP报文主要由报文首部和报文主体构成（中间以空行分界）。请求报文首部由请求行（方法 URI HTTP版本）、请求首部字段、通用首部字段、实体首部字段和其他首部组成。响应报文首部由状态行（HTTP版本 状态码）、响应首部字段、通用首部字段、实体首部字段和其他首部组成。</p>
<h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><ul>
<li>Cache-Control 控制缓存的行为，更多请查看<a href="http://baike.baidu.com/link?url=DKZzZAkL3zDoA0PHRZU2hytroVcR3bRad8MplCbsnH9bfKH6XDL8MdVlGQyORnSa6fbtUuvOc9IMnsW_mje1x_" target="_blank" rel="external">百度百科</a></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Cache指令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">所有内容都将被缓存(客户端和代理服务器都可缓存)</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)</td>
</tr>
<tr>
<td style="text-align:left">no-store</td>
<td style="text-align:left">所有内容都不会被缓存到缓存或 Internet 临时文件中</td>
</tr>
<tr>
<td style="text-align:left">must-revalidation/proxy-revalidation</td>
<td style="text-align:left">如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证</td>
</tr>
<tr>
<td style="text-align:left">max-age=xxx (xxx is numeric)</td>
<td style="text-align:left">缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高</td>
</tr>
<tr>
<td style="text-align:left">no-cache</td>
<td style="text-align:left">必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。</td>
</tr>
</tbody>
</table>
<ul>
<li>Connection：管理持久连接、控制不再转发给代理的首部字段。Keep-Alive：持久连接，HTTP/1.1版本和2.0版本都默认持久连接，在遇到Connection为close时，才会断开连接。</li>
<li>Date：表明创建HTTP报文的日期和时间。</li>
<li>Pragma：与HTTP/1.0兼容的字段，设为no-cache要求所有的中间服务器不返回缓存的资源。</li>
<li>Transfer-Encoding：规定传输报文主体时采用的编码方式。如gzip、chunked等</li>
<li>Upgrade：用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。使用方法为：Upgrade：TLS/1.0 Connection：Upgrade</li>
</ul>
<h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><ul>
<li>Accept：能够处理的媒体类型及媒体类型的相对优先级，如text/html、text/css、image/png等</li>
<li>Accept-Encoding：支持的内容编码及内容编码的优先级，如gzip、compress等</li>
<li>Accept-Language：支持的自然语言集及相对优先级，如zh-cn、en-us等</li>
<li>Host：虚拟主机运行在同一个IP上时，使用Host加以区分</li>
<li>If-Modified-Since：如果在该字段指定的日期后，资源发生了更新，服务器会接收请求</li>
<li>If-None-Match：如果没有该Etag相匹配，处理该请求。可在get或head方法中使用它可获取最新的资源。</li>
<li>Referer：会告知服务器请求的原始资源的URI，即哪个web页面发起的请求。</li>
<li>User-Agent：创建请求的浏览器和用户代理名称等信息</li>
</ul>
<h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><ul>
<li>Etag：每个资源的唯一性标识，资源更新，则Etag更新。</li>
<li>Location：配合3**重定向响应，提供重定向的URI。</li>
<li>Server：服务器上安装的HTTP服务器应用程序的信息。</li>
</ul>
<h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><ul>
<li>Allow：服务器支持的所有HTTP方法，使用option方法可返回该字段</li>
<li>Content-Encoding：实体的主体部分选用的内容编码方式。</li>
<li>Content-Language：如zh-CN</li>
<li>Content-Length：实体主体部分的大小（单位为字节）</li>
<li>Content-Type：实体主体内对象的媒体类型。如text/html等</li>
<li>Expires：资源失效的日期</li>
<li>Last-Modified：资源最后修改的时间</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>Set-Cookie：status=enable；expires：Tue，05 Jul 2011 07:26:31 GMT；path=/;domain:.hackr.jp;（NAME=VALUE以及失效期、目录、域名等）Secure表示仅在HTTPS下才发送Cookie，HttpOnly，表示Cookie不能被JavaScript脚本访问。</li>
<li>Cookie：发送cookie名称及相应的值</li>
<li>X-XSS-Protection：针对跨站脚本攻击（XSS）的一种对策。0：将XSS过滤设置成无效状态；1：有效状态</li>
</ul>
<h2 id="常用TTTP码"><a href="#常用TTTP码" class="headerlink" title="常用TTTP码"></a>常用TTTP码</h2><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><ul>
<li>101 转换协议<h4 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h4></li>
<li>200：服务器已成功处理了请求并提供了请求的网页。</li>
<li>204：服务器成功处理了请求，但没有返回任何内容。<h4 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h4></li>
<li>301：请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。</li>
<li>302：请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL</li>
<li>304：如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。<h4 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h4></li>
<li>400：服务器不理解请求的语法。</li>
<li>403：服务器拒绝请求。</li>
<li>404：服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。</li>
<li>410：请求的资源永久删除后，服务器返回此响应。该代码与404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404页面代码。如果资源已永久删除，应当使用301指定资源的新位置。<h4 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h4></li>
<li>500：服务器遇到错误，无法完成请求。</li>
<li>503：服务器目前无法使用（由于超载或停机维护）。</li>
<li>505：HTTP版本不受支持。</li>
</ul>
<h2 id="域名、URL、网站名"><a href="#域名、URL、网站名" class="headerlink" title="域名、URL、网站名"></a>域名、URL、网站名</h2><p><a href="http://mail.163.com/index.html" target="_blank" rel="external">http://mail.163.com/index.html</a></p>
<ul>
<li>http:// 这是个协议，即http超文本传输协议，也就是网页在网上传输的协议。</li>
<li>mail 这个是服务器名，代表一个邮箱服务器</li>
<li>163.com 这个是域名，是用来定位网站的独一无二的名字</li>
<li>mail.163.com 这个是网站名，由服务器名+域名组成</li>
<li>index.html 这个是根目录下得默认网页</li>
<li>整体叫做URL，统一资源定位符，定位网上资源。由协议 + 服务器 + 域名 + 网页html组成</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>1997年，HTTP1.1问世。HTTP1.0中出现的最大问题使连接无法复用和队头阻塞问题。针对连接无法复用问题，HTTP1.1通过connection实现长连接，针对队头阻塞问题，HTTP1.1提出管线化（然而存在很多缺陷，所以并没有被广泛使用）。</p>
<h4 id="客户端-服务器端"><a href="#客户端-服务器端" class="headerlink" title="客户端/服务器端"></a>客户端/服务器端</h4><p>仅从一条通信路线来说，应用HTTP协议时，必定一端担任客户端角色，另一端担任服务器角色。客户端发送请求，服务器端才能响应，不能实现服务器端推送功能。为了实现服务器端推送功能，就必须使用Comet等解决方法（保留响应直到服务器内容更新）。</p>
<h4 id="不保存状态的协议"><a href="#不保存状态的协议" class="headerlink" title="不保存状态的协议"></a>不保存状态的协议</h4><p>HTTP是一种不保存状态的协议，但为了实现期望的保持状态功能，于是引入了Cookie技术，但是该技术在很大程度上使首部膨胀，增加了数据传输压力，进而增加延迟。</p>
<h4 id="采用明文传输"><a href="#采用明文传输" class="headerlink" title="采用明文传输"></a>采用明文传输</h4><p>首部采用明文传输，所以首部数据量大，且不安全。为保证安全，要使用HTTPS协议。</p>
<h4 id="仍然存在队头阻塞问题"><a href="#仍然存在队头阻塞问题" class="headerlink" title="仍然存在队头阻塞问题"></a>仍然存在队头阻塞问题</h4><p>由于http1.1管线技术的缺陷，使用率较小。为了解决这个问题，主要使用图片合并、文件合并、内容内嵌等技术来减小请求次数，但是会导致文件粒度变大。</p>
<h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><p>SPDY针对HTTP1.1的痛点——延迟和安全性，从协议层次进行了技术改革，SPDY位于HTTP之下，TCP和SSL之上，实现了多路复用、请求优先级、header压缩、server推送、server暗示等功能，为了减少使用spdy的协商过程，SPDY规定，协商过程放到SSL协商过程中，从而避免增加延时。</p>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>由于SPDY的诞生和表现，催生了HTTP2.0的诞生。HTTP2.0最大的特点：不会改动HTTP的语义、方法、状态码、URI 及首部字段等。却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量，其核心在于新增的二进制分帧层。</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>由于cookie和user agent以及其他明文传输的头部，很容易让头部膨胀，增大了不必要的传输，所以HTTP2.0对头部进行了压缩。实现的方法为：通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的数据的大小。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在HTTP2.0中，多个请求和响应共用一个tcp通道。一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面。同时，每个stream都可以设置优先级和依赖，以保证优先级高的stream被优先处理。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2允许服务端针对客户端一个单独的请求，主动的发送(或推送)一个或者多个相关的响应。服务端推送语义上等同于服务端响应一个请求；然而，这种情况下请求也是由服务端发送的，作为一个PUSH_PROMISE帧。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS=HTTP+加密+认证+完整性保护，HTTPS是身披SSL外壳的HTTP，只是HTTP通信接口部分用SSL和TLS协议代替而已。<br>HTTPS采用混合加密机制，即使用公开密匙加密方式安全地交换在稍后的共享密匙加密中要使用的密匙，在确保交换的密匙是安全的前提下，使用共享密匙加密方式进行通信。公开密匙加密使用一对非对称的密匙——私有密匙和公开密匙，常用的公开密匙加密方法有：RSA算法、ElGamal算法等。除了加密外，还需要证明公开密匙正确性的证书，来证明公开密匙本身就是货真价实的公开密匙。<br>HTTPS通信步骤：</p>
<ol>
<li>客户端发送Client Hello报文，报文中包含客户端支持的SSL的指定版本、加密组件等。</li>
<li>服务器可进行SSL通信时，会以Server Hello报文作为应答（包含SSL版本等），并发送证书以及公开密匙。随后发送Server Hello Done报文。</li>
<li>客户端验证证书，然后使用公开密匙加密共享密匙（Pre-master secret），并将其包含包Client Key Exchange报文中发送，随后发送Change Cipher Spec报文，提示服务器，此后采用Pre-master secret密匙加密。最后发送Finished报文。</li>
<li>服务器同样发送Change Cipher Spec报文，并发送Finished报文。</li>
<li>SSL连接建立完成。</li>
</ol>
<p>相关资源：<br><a href="https://www.rfc-editor.org/rfc/rfc1945.txt" target="_blank" rel="external">HTTP1.0 RFC</a><br><a href="https://www.rfc-editor.org/rfc/rfc2616.txt" target="_blank" rel="external">HTTP1.1 RFC</a><br><a href="https://www.rfc-editor.org/rfc/rfc7540.txt" target="_blank" rel="external">HTTP2.0 RFC</a><br><a href="https://segmentfault.com/a/1190000004399183" target="_blank" rel="external">HTTP2.0那些事</a><br><a href="https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88%2806-29%29.md" target="_blank" rel="external">HTTP2.0 中英文对照</a><br>《图解HTTP》 上野宣 著 于均良 译</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/16/HTTP/" data-id="cioofeu3s000rm4q9vgsrpap6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机基础/">计算机基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/OOP/" class="article-date">
  <time datetime="2016-05-03T12:39:17.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/软件开发基础/">软件开发基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/OOP/">面向对象基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对象、类、实例"><a href="#对象、类、实例" class="headerlink" title="对象、类、实例"></a>对象、类、实例</h2><p>一起事物皆为对象，对象是一个自包含的实体，用一组可识别的特性和行为来标识。类就是具有相同的属性和功能的对象的抽象的集合，可以认为类是创建某一类对象的模板。实例是根据类实现的一个真实的对象，实现的过程称为实例化。</p>
<h2 id="构造方法与方法重载（overload）"><a href="#构造方法与方法重载（overload）" class="headerlink" title="构造方法与方法重载（overload）"></a>构造方法与方法重载（overload）</h2><p>构造方法又叫构造函数，其实就是对类进行初始化。根据参数的不同，可以由多种构造方法，方法重载提供了创建同名的多个方法的能力（参数不同）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">string</span> name = <span class="string">""</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h2><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>类的访问修饰符只有public、abstract等，不能使用private、protected等修饰符。属性和方法都有访问修饰符，常见的修饰符有（C#）：</p>
<ul>
<li>private 私有，只允许本类中的成员访问，子类、实例不能访问；</li>
<li>protected 保护访问， 允许本类、子类访问，实例不能访问；</li>
<li>internal 内部访问，指向本项目内访问，其他项目不能访问；</li>
<li>public 共有访问，不受任何限制；</li>
</ul>
<h4 id="set、get访问器"><a href="#set、get访问器" class="headerlink" title="set、get访问器"></a>set、get访问器</h4><p>属性有两个方法get、set。get访问器返回与声明的属性相同的数据类型；set访问器有一个隐式参数，用关键字value表示，进行赋值。使用构造器的好处有控制读写(是否可读、可写、对值的范围进行控制等)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ShouNum</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123; <span class="keyword">return</span> shouNum; &#125;</span><br><span class="line">	<span class="keyword">set</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">value</span>&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">			shouNum = <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装。适当的封装，可以将对象使用接口的程序实现部分隐藏起来，同时确保用户无法任意更改对象内部的重要的数据。封装有这两层的概念，指的是方法的实现。使用封装的好处有：减少耦合、类内部实现可以自由修改、类具有清晰的对外接口。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承定义了类如何相互关联，共享特性。子类（派生类）不但继承了父类（基类）的所有特性，还可以定义新的特性。继承的特性有：</p>
<ul>
<li>子类拥有父类非private的属性和功能；</li>
<li>子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；</li>
<li>子类还可以以自己的方式实现父类的功能（方法重写）；</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//对于构造方法，不能被继承，只能被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function">pulic <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态（override）"><a href="#多态（override）" class="headerlink" title="多态（override）"></a>多态（override）</h4><p>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。<br>在C#中，多态的实现方法为：父类通过virtual关键词，将成员声明为虚拟的，表示这个方法/属性可以被重写；然后，子类可以选择使用override关键字，来重写方法。不同的语言实现多态的方法有差别。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//在C#中，要声明为虚函数，才可以重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 ... <span class="comment">//重写的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。如果行为跨越不同类的对象，可使用接口，对于一些相似的类对象，用继承抽象类。从设计角度看，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。<br>抽象类和接口还有一些其他的具体的区别：</p>
<ul>
<li>抽象类可以给出一些成员的实现，接口却不包含成员的实现。</li>
<li>抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现。</li>
<li>一个类只能继承一个抽象类，但可以实现多个接口等</li>
</ul>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类不能实例化，只是类的抽象</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> getShoutSound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口，应该是现有接口，再由类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing);<span class="comment">//此为继承接口的类要实现的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MachineCat</span>:<span class="title">Cat</span>,<span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing) <span class="comment">//不需要override</span></span><br><span class="line">	&#123; <span class="comment">//方法的实现 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合和泛型"><a href="#集合和泛型" class="headerlink" title="集合和泛型"></a>集合和泛型</h2><p>集合ArrayList是使用大小可按需动态增加的数组，可以通过泛型为其制定集合中的类型。泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、接口、接口和方法所存储和使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作为它所存储的对象的类型的占位符。使用方法如: List<animal> arrayAnimal。</animal></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/OOP/" data-id="cioofeu7e003vm4q96bcax7de" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WebApp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/WebApp/" class="article-date">
  <time datetime="2016-04-23T08:46:13.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/WebApp/">Web应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>所谓Web应用，指的是使用web技术构建的业务繁杂、逻辑较多、交互频繁的单页Web应用，它在一个界面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面。它是Ajax技术的进一步升华，把Ajax的无刷新机制发挥到极致，因此能早就与桌面程序媲美的流畅用户体验。</p>
<h2 id="Web应用需要解决的问题"><a href="#Web应用需要解决的问题" class="headerlink" title="Web应用需要解决的问题"></a>Web应用需要解决的问题</h2><p>根据徐飞前辈的分类，Web应用中要解决的问题分为三类：状态、组织、效率。<a href="http://www.zhihu.com/question/39943474" target="_blank" rel="external">原文</a></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>在一个业务界面中，我们可能会根据某些数据去生成一块界面，然后根据界面上的某些操作，改变一些数据，进而影响界面另外一部分。所以抽象出来就有两种关系：数据改变造成界面改变、界面改变造成数据改变。能够描述界面当前状态的数据，就称为状态。如果不对状态进行抽象，则可能造成逻辑的混乱，所以，不同的框架采用不同的方式进行了处理。</p>
<h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>所谓组织，指两个方面，一方面是模块关系，一方面是业务模型。<br>目前解决模块关系的问题的共识是组件化。整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。最原始的组件，其功能可以单独开发测试，然后逐级拼装成更复杂的组件，直到整个应用。每一级都是易装配，可追踪，可管控的。组件化的目标有分治和复用，其中分治的价值更大。由于组件设计需要更高的成本和更高的难度，所以对web应用“全组件化”是有一定的难度的，可综合考虑。<br>所谓业务模型指的是所处领域中的业务数据、规则、流程的集合。目前解决业务模型的方法有flux、redux之类的架构。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>效率分为开发效率和运行效率。开发效率与选用的框架、技术以及组件化等都有很大的关系。运行效率主要因素有数据变更检测方式和创建、修改DOM。数据变更检测方式和框架有很大的关系，创建DOM的过程中，各个框架之间没有太大差异，而在修改DOM的时候，React的虚拟DOM有很大的优秀，其他框架内部实现也在逐渐借鉴。</p>
<h2 id="常见的架构"><a href="#常见的架构" class="headerlink" title="常见的架构"></a>常见的架构</h2><p>目前在Web应用中，常用的架构有MVC、MVP、MVVM三种。下面这两篇文章讲的很好。<br><a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" target="_blank" rel="external">Scaling Isomorphic Javascript Code</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></p>
<h2 id="开发框架与类库"><a href="#开发框架与类库" class="headerlink" title="开发框架与类库"></a>开发框架与类库</h2><p>通常，我们会开始用类库和框架来解决构建动态应用的问题。类库是一些函数的集合，它可以帮助我们写Web应用，但起主导作用的是我们的代码，如jQuery。而框架是一种特殊的、已经实现了的Web应用，它只需要填充具体的业务逻辑，其主导作用的是框架。</p>
<ul>
<li>ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成前端的开发以及布局。然而，随着功能的逐渐增加，ExtJS的体积变得日益庞大，性能也变得越来越差。</li>
<li>React可以认为是MVC中的V视图，其产生的意义是：解决构建随时间数据不断变化的大规模应用程序的问题。其主要特点是组件化（也可以使用其独有的jsx）和虚拟DOM树（只会更新需要更新的DOM，节省大量的DOM修改的时间）。React推崇的是单向数据流：给定原始界面，施加一个变化，就可以推导出顶一个状态（界面或数据的更新）</li>
<li>Angular是为了克服HTML在构建应用上的不足而设计的。它采用了MVVM的架构，采用了数据与界面的双向数据绑定，当界面发生变化时，按照配置规则去更新相应的数据，然后，在根据配置好的规则，把数据更新到界面状态。</li>
<li>Vue是一个构建数据驱动的web界面的库。Vue.js的目标是通过尽可能简单的API实现相应的数据绑定和组合的视图组件。它只聚焦于视图层，非常容易与其他库或已有项目整合。其核心是一个响应的数据绑定系统，它让数据与DOM保持同步变得非常简单。<a href="http://cn.vuejs.org/guide/comparison.html" target="_blank" rel="external">与其他框架的对比</a></li>
<li>jQuery是一个优秀的JavaScript库，它是轻量级的js库，兼容CSS3以及各种浏览器。jQuery是用户能更方便地处理HTML、events、实现动画效果和AJAX交互。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/WebApp/" data-id="cioofeu7j003ym4q98iohnl3v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flexbox" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/flexbox/" class="article-date">
  <time datetime="2016-04-23T05:26:23.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/flexbox/">flexbox</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文大量参考了Helen Emerson的<a href="http://helephant.com/2013/03/23/css3-flexbox-layout/" target="_blank" rel="external">《Using the CSS3 flexbox layout》</a>，如有需要，请移步此文。</p>
<h2 id="Flexbox简述"><a href="#Flexbox简述" class="headerlink" title="Flexbox简述"></a>Flexbox简述</h2><p>Flexbox的布局是一个用于页面布局的CSS3模块，目前为止，大部分的浏览器都支持或部分支持此功能，支持情况请参考<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">caniuse网站</a>。Flexbox可以简单快速的创建一个具有弹性功能的布局，当在一个小屏幕上显示的时候，Flexbox可以让元素在伸缩容器中进行自由扩展和收缩，从而调整整个布局。</p>
<h2 id="伸缩容器和伸缩项目"><a href="#伸缩容器和伸缩项目" class="headerlink" title="伸缩容器和伸缩项目"></a>伸缩容器和伸缩项目</h2><p>一个flexbox布局由伸缩容器和其中的伸缩项目组成。伸缩容器是一个HTML标签元素，并且“display”属性显示设置“flex”属性值，伸缩容器中的所有子元素都会自动变成伸缩项目（flex items）。</p>
<h2 id="伸缩方向与换行（flex-flow）"><a href="#伸缩方向与换行（flex-flow）" class="headerlink" title="伸缩方向与换行（flex-flow）"></a>伸缩方向与换行（flex-flow）</h2><p>伸缩容器有一个CSS属性“flex-flow”用来决定伸缩项目的布局方式。常见的flex-flow的值有row、column、row wrap等，其伸缩项目排列方式如下：</p>
<p><img src="/img/CSS3/flexflow-row.png" alt="flex-flow:row"><br><img src="/img/CSS3/flex-flow-column.png" alt="flex-flow:column"><br><img src="img/CSS3/flexbox-rowwrap.png" alt="flex-flow:row wrap"></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row; <span class="comment">//还有columen、warp、row warp等</span></span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">1000px</span>; <span class="comment">//还可以使用max-widht等属性设置最大/最小宽度/高度等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伸缩项目设置"><a href="#伸缩项目设置" class="headerlink" title="伸缩项目设置"></a>伸缩项目设置</h2><p>伸缩容器中的所有子元素都将自动变成伸缩项目，仅需要设置伸缩项目的尺寸即可。设置其尺寸可以使用widht、height等固定伸缩项目的宽和高，也可以使用flex属性（还可以结合min-widht等属性）动态改变伸缩项目的尺寸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row wrap；</span><br><span class="line">	max-width: <span class="number">1500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-widht</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">	<span class="attribute">min-widht</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSS3/flex-item-width.png" alt=""><br>在以上容器中，为left right都设置flex，最小/最大宽度，而mian设置了固定宽600px。其排列规则如下（在chrome中验证）：</p>
<ol>
<li>当宽度足够宽时，先去除main的600px固定宽，left和right宽度比为1:2（超过max-widht，长度自动设为max-width的值）。</li>
<li>当宽度不足时，优先满足left的min-widht和mian的widht。如果无法满足right的min-widht，right转到第二行。一次类推。</li>
<li>所以，可以结合min-widht、max-widht和flex动态调整元素大小，并使元素不至于过大或者过小。</li>
<li>计算规则为先按照flex分配元素尺寸（如果只有一个flex，则其填充剩余空白），然后参考最大最小尺寸，确定元素尺寸。每个元素都自动有一个隐式的最小尺寸，这里需要注意一下。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/flexbox/" data-id="cioofeu7l0043m4q97wyje8t4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/react-learn/" class="article-date">
  <time datetime="2016-04-17T13:13:55.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/react-learn/">react初步认识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React起源于Facebook的内部项目，其设计思想及其独特，属于革命性创新，性能出众，代码逻辑简单。其主要优点有：</p>
<ol>
<li>虚拟DOM，在必要的时候才将组件渲染到真正的DOM上，减少频繁的DOM操作造成的性能问题。</li>
<li>组件化，React都是关于构建可复用的组件。事实上，通过React唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离更加简单。</li>
</ol>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
    &lt;script src=&quot;http://fb.me/react-0.13.0.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;http://fb.me/JSXTransformer-0.13.0.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/jsx&quot;&gt;
      var HelloWorld = React.createClass({
          render: function() {
            return (
                  &lt;p&gt;
                    Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot; /&gt;!
                    It is {this.props.date.toTimeString()}
                  &lt;/p&gt;
            );
          }
        });

        setInterval(function() {
              React.render(
                &lt;HelloWorld date={new Date()} /&gt;,
                document.getElementById(&apos;example&apos;)
              );
        }, 500);

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>React提供了一个官方例子<a href="http://reactjs.cn/react/blog/2013/11/05/thinking-in-react.html" target="_blank" rel="external">英文</a><a href="http://reactjs.cn/react/docs/thinking-in-react.html" target="_blank" rel="external">中文</a>，从如何拆分组件树、如何利用React创建静态版本、如何识别最小的state、如何确认state的声明周期到添加方向数据流，较完整的展现了react的应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/17/react-learn/" data-id="cioofeu92005fm4q9a33ccp5o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-async" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-async/" class="article-date">
  <time datetime="2016-04-14T19:25:50.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-async/">ECMAScript6中的异步操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>Generator函数是ES6提供的一种异步编程解决方案，我们可以将Generator函数理解成一个状态机，执行这个函数会返回一个遍历器对象。Generator函数内部使用yield语句，没执行一次函数的next方法，执行到下一个yield，直到函数结束，从而达到异步调用函数的目的。此外，yield本身没有返回值，next方法可以带一个参数，该参数将被当做上一个yield语句的返回值，实现在generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般与for of结合的使用方法，不需要使用next方法</span></span><br><span class="line"><span class="built_in">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="built_in">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);  <span class="comment">//在generator函数中调用另一个generator函数，要使用yield*</span></span><br><span class="line">    &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125; <span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过next函数注入不同的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; 5+24+13=42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数的改写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> loader = loadUI();</span><br><span class="line"></span><br><span class="line">loader.next();<span class="comment">// 加载UI</span></span><br><span class="line">loader.next(); <span class="comment">//// 卸载UI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部署Ajax操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="built_in">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response); <span class="comment">//将response作为值传入</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">//执行request操作</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。Promise独享的状态（pending、resolved、rejected）不受外界影响，只有异步操作的结果可以决定当前是哪一种状态。一旦状态发生改变，就不再变。如果某些事件不断反复发生，一般阿狸说，使用stream模式比部署Promise更好。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line"><span class="built_in">var</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">//接收一个函数，函数有两个参数</span></span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">//接收两个函数，分别在成功和失败的时候执行</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步加载图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + <span class="built_in">url</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = <span class="built_in">url</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//generator和promise的结合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="decorator"><span class="keyword">try</span></span> &#123;</span><br><span class="line">    <span class="built_in">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h2 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h2><p>ES6之前，异步编程的方法，大概有：回调函数、事件监听、发布/订阅、Promise对象，ES6则应用generator函数是异步编程进入全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="comment">//1.回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise</span></span><br><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); <span class="comment">//读入A后，读取B，则会出现多重嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.协程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.generator</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.Async</span></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>); <span class="comment">//await表示紧跟后面的表达式需要等待结果</span></span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>); <span class="comment">//返回Promise对象，如果不是，则转为promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-async/" data-id="cioofeu2z0009m4q9lk99d2of" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-class/" class="article-date">
  <time datetime="2016-04-14T19:24:56.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-class/">ECMAScript6中的Class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本质上，ES6只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性，Class和let一样，不存在变量提升。ES6实现了类的继承，类的静态方法，但是目前没有规定类的静态属性，在ES7中，有关于静态属性的提议。</p>
<h2 id="Class类基础"><a href="#Class类基础" class="headerlink" title="Class类基础"></a>Class类基础</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line">Class  Point &#123; <span class="comment">//其实它可以看做构造函数的另一种写法。</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x; <span class="comment">//显示定义在本身，而不是原型上</span></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; <span class="comment">//class这种写法，方法是不可枚举的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>Class之间可以通过extends关键字实现继承。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">//this是继承父类的this对象，然后对其进行加工</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// super代表父类实例，调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的prototype和proto属性"><a href="#类的prototype和proto属性" class="headerlink" title="类的prototype和proto属性"></a>类的prototype和<em>proto</em>属性</h2><p>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。一、子类的<em>proto</em>属性，表示构造函数的继承，总是指向父类。二、子类prototype属性的<em>proto</em>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。父类的静态方法，可以被子类继承。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod() <span class="comment">//typeeror static方法不会被实例继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> super.classMethod()+<span class="string">'too'</span>; <span class="comment">//可以从super对象上调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod() <span class="comment">//'hello' static方法可以被子类继承，</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-class/" data-id="cioofeu2n0005m4q9mmygpkxu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-iterator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6-iterator/" class="article-date">
  <time datetime="2016-04-14T13:28:33.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6-iterator/">ECMAScript6新属性方法等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6中添加了一些新的结构、属性、方法等，下面将进行简单的说明。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES5的对昂属性名都是字符串，容易造成属性名的冲突。ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，它是JavaScript的第七种数据类型，通过Symbol函数生成。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'Hello!'</span>&#125;; <span class="comment">//symbol属性不能使用.运算符</span></span><br><span class="line">a[mySymbol] <span class="comment">//"Hello!" symbol属性不能使用.运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>); <span class="comment">//必须都是用for，且输入值相同，才相等</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 == s2  <span class="comment">//true 使用symbol.for可以实现两个symbol相同</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">//"foo" sysmol.for()有登记制，symbol()没有，登记的会返回字符串参数</span></span><br></pre></td></tr></table></figure>
<h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h4 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h4><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set的方法有四个：set.add(value)、set.delete(value)、set.has(value)、set.clear()清除所有成员。如果要读取或者遍历可以将set通过Array.from(set)转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">"4"</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>]);</span><br><span class="line">alert(set.size); <span class="comment">//6 在set内部，4不等于“4”（不会发生类型转换），NaN等于NaN，对象总是不等于对象&#123;&#125;不等于&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>)</span>&#123; <span class="comment">//数组去重的方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet与Set类似，也是不重复的值的集合，但是它与Set有两个区别。一、WeakSet的成员只能是对象。二、WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]; <span class="comment">//数组的成员只能是对象，不能是变量</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br></pre></td></tr></table></figure>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。ES6提供了Map数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键，是一种更完善的Hash结构实现。<br>Map原生提供三个遍历器生成函数和一个遍历方法。entries()、keys()、values()、forEach()。<br>Map可以与数组、对象、Json相互转换。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">m</span> = new Map();</span><br><span class="line"><span class="keyword">var</span> o = &#123;p:<span class="string">"hello tecent"</span>&#125;;</span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">set</span>(o,<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">m</span>.<span class="built_in">get</span>(o); <span class="comment">//"content"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">m</span>.size <span class="comment">//1</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.delete(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">clear</span>(); <span class="comment">//全部清空</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap与Map结构基本类似，唯一的区别是它只接受对象做为键名(null除外)，而且键名所指向的对象，不计入垃圾回收机制。其设计目的在于，键名是对象的弱引用。</p>
<h2 id="Iterator遍历器与for…of循环"><a href="#Iterator遍历器与for…of循环" class="headerlink" title="Iterator遍历器与for…of循环"></a>Iterator遍历器与for…of循环</h2><p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。其遍历过程如下：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象（字符串等）、Set和Map结构。另外，也可以手动为对象等添加Iterator接口。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = ['a', 'b'];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="type">Symbol</span>.<span class="keyword">iterator</span>](); //默认的<span class="type">Iterator</span>接口部署在数据结构的<span class="type">Symbol</span>.<span class="keyword">iterator</span>属性</span><br><span class="line">iter.next() // &#123; value: 'a', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: 'b', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr =['b','c'];</span><br><span class="line">['a',…arr,'d'] //['a','b','c','d'] 扩展运算符会调用默认的<span class="keyword">iterator</span>接口</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = ['a', 'b', 'c', 'd'];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">in</span>循环，只获得对象的键名</span><br><span class="line">  console.log(a); // <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">of</span>循环，获得对象的键值，只返回具有数字索引的属性</span><br><span class="line">  console.log(a); // a b c d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = new <span class="type">Map</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [name,value] <span class="keyword">of</span> map)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6-iterator/" data-id="cioofeu3l000nm4q9gux3ez9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6/" class="article-date">
  <time datetime="2016-04-14T07:35:01.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6/">ECMAScript6为数据类型添加的新方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6在2015年6月正式发布。它的目标，是是的JavaScript语言可以用来编写复杂的大型应用陈旭，称为企业级开发语言。ECMAScript是JavaScript的规格，后者有时前者的一种实现。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><p>ES6新增let命令，用来声明变量，用法类似于var。区别为：</p>
<ul>
<li>let所声明的变量，只在let命令所在的代码块内有效。</li>
<li>let不存在“变量提升”现象，即其变量的定义是在JavaScript的代码执行阶段。</li>
<li>let存在暂时性死区，即又要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。</li>
<li>let实际上为JavaScript新增了块级作用域；<br>如此便解决了块级局部变量以及for循环中局部变量的问题。解决了如下一个大问题：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">//i为局部变量，</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">5</span>](); <span class="comment">//5，每次的i都是一个新的变量</span></span><br></pre></td></tr></table></figure>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p>const用来定义常量，一旦声明，常量的值就不能改变。</p>
<ul>
<li>严格模式下，重新赋值会报错，常规模式下，赋值无效不报错；</li>
<li>const声明时不赋值则不能赋值，常量为undefind。严格模式下，const声明时必须赋值，否则报错；</li>
<li>const存在块级作用域。</li>
</ul>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。可以用于交换变量的值、从函数返回多个值、函数参数定义、解析jsondata等。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]]; </span><br><span class="line">bar <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>]; <span class="comment">//a=1,b=undefined</span></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//解构不完全，但可以成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认值</span></span><br><span class="line"><span class="keyword">var</span> [c=<span class="number">1</span>,d=<span class="number">2</span>,e=<span class="number">3</span>] = [<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="number">5</span>]; <span class="comment">//1,null,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用途</span></span><br><span class="line">[x,y] = [y,x]; <span class="comment">//交换变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a,b,c] = example(); <span class="comment">//从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x,y,z])</span></span>&#123;……&#125;</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">//函数参数定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析jsondata等</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>String类型主要添加了遍历字符、字符串的头尾判断、字符串重复、字符的有关Unicode表示等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(codePoint); <span class="comment">//分别显示 f o o ，遍历字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s=<span class="string">'Hello world'</span>;</span><br><span class="line">s.startWith(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line">s.endWith(<span class="string">'Hello'</span>,<span class="number">5</span>); <span class="comment">//true,可以添加第二个参数，表示搜索的位置。</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>); <span class="comment">//"hellohello"</span></span><br></pre></td></tr></table></figure>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>新增了是否为无穷、NaN判断，是否为整数，安全整数，另外，parseInt()、parseFloat()方法也放到了Number对象的下面。Math对象的话则添加了获取整数部分，返回正负值，立方根、对数等。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> // <span class="number">0b</span>二进制 <span class="literal">true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> // <span class="number">0o</span>八进制 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Number.isFinite(<span class="number">0.8</span>); //<span class="literal">true</span> 是否为非无穷,检查Infinate特殊值</span><br><span class="line">Number.isNaN(NaN); //<span class="literal">true</span> 是否为NaN，检查NaN特殊值</span><br><span class="line"></span><br><span class="line">Number.parseInt('<span class="number">12.34</span>'); //<span class="number">12</span> 将全局方法parseInt()、parseFloat()，移植到Number对象上</span><br><span class="line">Number.parseFloat('<span class="number">12.45</span>#'); //<span class="number">12.45</span></span><br><span class="line"></span><br><span class="line">Number.isInteger(<span class="number">3.0</span>); //<span class="literal">true</span> 是否为整数，JavaScript中，整数和浮点数使用同样的存储方法，所以<span class="number">3</span>和<span class="number">3.0</span>视为一个值</span><br><span class="line">Number.isSafeInteger(Math(<span class="number">2</span>,<span class="number">53</span>)-<span class="number">1</span>); /<span class="literal">true</span>，JavaScript能够精确表示-<span class="number">2</span>^<span class="number">53</span>到-<span class="number">2</span>^<span class="number">53</span>间的整数（不含端点），超过则无法精确表示这个值</span><br><span class="line"></span><br><span class="line">Math.<span class="built_in">trunc</span>(<span class="number">4.1</span>); //<span class="number">4</span> 用于取出一个数的小数部分，返回整数部分</span><br><span class="line">Math.<span class="built_in">sign</span>(-<span class="number">5</span>); //-<span class="number">1</span> 参数为正数返回+<span class="number">1</span> 其他返回+<span class="number">0</span>、<span class="number">0</span>、+<span class="number">0</span>、-<span class="number">1</span>和NaN</span><br><span class="line">Math.cbrt(<span class="number">2</span>); //<span class="number">1.2599210498948734</span> 返回一个数的立方根</span><br><span class="line"></span><br><span class="line">//还有对数方法、关于<span class="number">32</span>位无符号数的方法等</span><br></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>新增了将类数组转换为数组、将一组值转换为数组的方法，通过find()查找第一个符合条件的数组成员，通过fill填充数组，还可以通过entries()等方法返回键值对数组等。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike=&#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="string">'2'</span>:<span class="string">'c'</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line">var arr1 = [].slice.call(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES5</span>的方法</span><br><span class="line">let arr2 = <span class="symbol">Array</span>.from(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES6</span>的方法</span><br><span class="line"><span class="symbol">Array</span>.from(<span class="string">'abcde'</span>); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br><span class="line"><span class="symbol">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x); //[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>] 接收第二个参数，对每个元素进行处理</span><br><span class="line"></span><br><span class="line"><span class="symbol">Array</span>.of(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>); //[<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>] 将一组值，转换为数组，主要目的是弥补数组构造函数<span class="symbol">Array</span>()的不足</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find((n) =&gt; n&lt;<span class="number">0</span>); //<span class="number">-5</span> 用于找出第一个符合条件的数组成员</span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>); //[<span class="string">'a'</span>,<span class="number">7</span>,<span class="string">'c'</span>] 第一个参数表示填充值，剩下两个表示填充起始位置和结束位置</span><br><span class="line"></span><br><span class="line">//entries() keys() values()用于遍历数组，分别表示遍历键值对、键、值</span><br><span class="line">for(let [index,elem] of [<span class="string">'a'</span>,<span class="string">'b'</span>].entries())&#123;</span><br><span class="line">	console.log(index,elem);</span><br><span class="line">&#125; //<span class="number">0</span> <span class="string">"a"</span>   <span class="number">1</span>  <span class="string">"b"</span> </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>); //true 是否包含给定数值</span><br></pre></td></tr></table></figure>
<h2 id="函数参数的扩展"><a href="#函数参数的扩展" class="headerlink" title="函数参数的扩展"></a>函数参数的扩展</h2><p>函数中新增了设置参数默认值、rest参数等功能，并且新增了箭头函数，尾递归优化等，并且可以通过函数的length属性获取其无默认值参数的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = 0, y = 0</span>) </span>&#123; <span class="comment">//设置参数默认值</span></span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">5</span>); <span class="comment">//p.x=5,p.y=0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常定义了默认值的参数，应该是函数的尾参数，因为输入f(,)这种没有赋值的函数会出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y=1</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [x,y];</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">//[2,1] 这样就可以省略尾部的有默认值的参数</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=1</span>)</span>&#123;&#125;&#125;).length <span class="comment">//2 返回没有指定默认值的参数个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定参数是否可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//会抛出错误，因为mustBeProvided默认值为抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量数量不定，rest参数。values变量表示一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">var</span> f = v =&gt; v*v; <span class="comment">//f(2)等于4</span></span><br><span class="line"><span class="keyword">var</span> sum = (num1,num2) =&gt; num1+num2 <span class="comment">//等同于下面</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1,num2</span>)</span>&#123; <span class="keyword">return</span> num1+num2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，只保留一个调用记录（严格模式下开启），复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>对象的扩展对象合并、属性遍历、返回对象键值数组等</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">//true 只要两个值一样，就相等，不同于===</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">"12"</span>,<span class="number">12</span>) <span class="comment">//false 不进行自动转换类型，不同于==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象合并，常用于为对象添加属性和方法以及克隆对象等</span></span><br><span class="line"><span class="built_in">var</span> target = &#123; <span class="attribute">a</span>: <span class="number">1</span>, <span class="attribute">b</span>: <span class="number">1</span> &#125;; <span class="comment">//合并对象，只是浅复制</span></span><br><span class="line"><span class="built_in">var</span> source1 = &#123; <span class="attribute">b</span>: <span class="number">2</span>, <span class="attribute">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1); <span class="comment">//&#123; a:1, b: 2, c: 2&#125;将后面的对象都复制到第一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的遍历</span></span><br><span class="line"><span class="keyword">for</span>……<span class="keyword">in</span> <span class="comment">//遍历对象自身和继承的可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)  <span class="comment">//返回一个数组，包含对象自身（不含继承的）所有可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)  <span class="comment">//返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象的键值对数组、键数组和值数组</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">//返回obj对象的值数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">//返回obj对象的键数组</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">//[["a","1"],["b",2]] 返回obj对象的值数组</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6/" data-id="cioofeu3e000im4q91fly08k5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ExtJS/">ExtJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端框架/">前端框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发基础/">软件开发基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Language/">C-Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C语言/">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExtJS/">ExtJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发/">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端框架/">前端框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机基础/">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ajax/" style="font-size: 11.67px;">Ajax</a> <a href="/tags/C-Language/" style="font-size: 10px;">C-Language</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/C语言/" style="font-size: 11.67px;">C语言</a> <a href="/tags/ExtJS/" style="font-size: 13.33px;">ExtJS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 18.33px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TCP-IP/" style="font-size: 11.67px;">TCP/IP</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/前端开发/" style="font-size: 20px;">前端开发</a> <a href="/tags/前端开发，CSS3/" style="font-size: 10px;">前端开发，CSS3</a> <a href="/tags/前端框架/" style="font-size: 11.67px;">前端框架</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/计算机基础/" style="font-size: 16.67px;">计算机基础</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/软件开发基础/" style="font-size: 10px;">软件开发基础</a> <a href="/tags/链接集/" style="font-size: 10px;">链接集</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/26/valueIsEqual/">JS中两个值是否相等&amp;类型转换</a>
          </li>
        
          <li>
            <a href="/2016/05/16/HTTP/">HTTP协议</a>
          </li>
        
          <li>
            <a href="/2016/05/03/OOP/">面向对象基础概念</a>
          </li>
        
          <li>
            <a href="/2016/04/23/WebApp/">Web应用</a>
          </li>
        
          <li>
            <a href="/2016/04/23/flexbox/">flexbox</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Rancho<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>