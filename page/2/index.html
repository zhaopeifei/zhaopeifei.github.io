<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>步步为营，勇往直前</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="步步为营，勇往直前">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="步步为营，勇往直前">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="步步为营，勇往直前">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="步步为营，勇往直前" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">步步为营，勇往直前</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">赵培霏的学习博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-OOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/OOP/" class="article-date">
  <time datetime="2016-05-03T12:39:17.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/软件开发基础/">软件开发基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/OOP/">面向对象基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对象、类、实例"><a href="#对象、类、实例" class="headerlink" title="对象、类、实例"></a>对象、类、实例</h2><p>一起事物皆为对象，对象是一个自包含的实体，用一组可识别的特性和行为来标识。类就是具有相同的属性和功能的对象的抽象的集合，可以认为类是创建某一类对象的模板。实例是根据类实现的一个真实的对象，实现的过程称为实例化。</p>
<h2 id="构造方法与方法重载（overload）"><a href="#构造方法与方法重载（overload）" class="headerlink" title="构造方法与方法重载（overload）"></a>构造方法与方法重载（overload）</h2><p>构造方法又叫构造函数，其实就是对类进行初始化。根据参数的不同，可以由多种构造方法，方法重载提供了创建同名的多个方法的能力（参数不同）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">string</span> name = <span class="string">""</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h2><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>类的访问修饰符只有public、abstract等，不能使用private、protected等修饰符。属性和方法都有访问修饰符，常见的修饰符有（C#）：</p>
<ul>
<li>private 私有，只允许本类中的成员访问，子类、实例不能访问；</li>
<li>protected 保护访问， 允许本类、子类访问，实例不能访问；</li>
<li>internal 内部访问，指向本项目内访问，其他项目不能访问；</li>
<li>public 共有访问，不受任何限制；</li>
</ul>
<h4 id="set、get访问器"><a href="#set、get访问器" class="headerlink" title="set、get访问器"></a>set、get访问器</h4><p>属性有两个方法get、set。get访问器返回与声明的属性相同的数据类型；set访问器有一个隐式参数，用关键字value表示，进行赋值。使用构造器的好处有控制读写(是否可读、可写、对值的范围进行控制等)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ShouNum</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123; <span class="keyword">return</span> shouNum; &#125;</span><br><span class="line">	<span class="keyword">set</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">value</span>&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">			shouNum = <span class="keyword">value</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装。适当的封装，可以将对象使用接口的程序实现部分隐藏起来，同时确保用户无法任意更改对象内部的重要的数据。封装有这两层的概念，指的是方法的实现。使用封装的好处有：减少耦合、类内部实现可以自由修改、类具有清晰的对外接口。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承定义了类如何相互关联，共享特性。子类（派生类）不但继承了父类（基类）的所有特性，还可以定义新的特性。继承的特性有：</p>
<ul>
<li>子类拥有父类非private的属性和功能；</li>
<li>子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；</li>
<li>子类还可以以自己的方式实现父类的功能（方法重写）；</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//对于构造方法，不能被继承，只能被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="keyword">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">	<span class="function">pulic <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态（override）"><a href="#多态（override）" class="headerlink" title="多态（override）"></a>多态（override）</h4><p>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。<br>在C#中，多态的实现方法为：父类通过virtual关键词，将成员声明为虚拟的，表示这个方法/属性可以被重写；然后，子类可以选择使用override关键字，来重写方法。不同的语言实现多态的方法有差别。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//在C#中，要声明为虚函数，才可以重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Animal</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">Shout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 ... <span class="comment">//重写的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。如果行为跨越不同类的对象，可使用接口，对于一些相似的类对象，用继承抽象类。从设计角度看，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。<br>抽象类和接口还有一些其他的具体的区别：</p>
<ul>
<li>抽象类可以给出一些成员的实现，接口却不包含成员的实现。</li>
<li>抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现。</li>
<li>一个类只能继承一个抽象类，但可以实现多个接口等</li>
</ul>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类不能实例化，只是类的抽象</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> getShoutSound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口，应该是现有接口，再由类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing);<span class="comment">//此为继承接口的类要实现的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MachineCat</span>:<span class="title">Cat</span>,<span class="title">IChange</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> ChangeThing(<span class="keyword">string</span> thing) <span class="comment">//不需要override</span></span><br><span class="line">	&#123; <span class="comment">//方法的实现 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合和泛型"><a href="#集合和泛型" class="headerlink" title="集合和泛型"></a>集合和泛型</h2><p>集合ArrayList是使用大小可按需动态增加的数组，可以通过泛型为其制定集合中的类型。泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、接口、接口和方法所存储和使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作为它所存储的对象的类型的占位符。使用方法如: List<animal> arrayAnimal。</animal></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/OOP/" data-id="cir0r64360033n4q9pyuumvpx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WebApp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/WebApp/" class="article-date">
  <time datetime="2016-04-23T08:46:13.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/WebApp/">Web应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>所谓Web应用，指的是使用web技术构建的业务繁杂、逻辑较多、交互频繁的单页Web应用，它在一个界面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面。它是Ajax技术的进一步升华，把Ajax的无刷新机制发挥到极致，因此能早就与桌面程序媲美的流畅用户体验。</p>
<h2 id="Web应用需要解决的问题"><a href="#Web应用需要解决的问题" class="headerlink" title="Web应用需要解决的问题"></a>Web应用需要解决的问题</h2><p>根据徐飞前辈的分类，Web应用中要解决的问题分为三类：状态、组织、效率。<a href="http://www.zhihu.com/question/39943474" target="_blank" rel="external">原文</a></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>在一个业务界面中，我们可能会根据某些数据去生成一块界面，然后根据界面上的某些操作，改变一些数据，进而影响界面另外一部分。所以抽象出来就有两种关系：数据改变造成界面改变、界面改变造成数据改变。能够描述界面当前状态的数据，就称为状态。如果不对状态进行抽象，则可能造成逻辑的混乱，所以，不同的框架采用不同的方式进行了处理。</p>
<h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>所谓组织，指两个方面，一方面是模块关系，一方面是业务模型。<br>目前解决模块关系的问题的共识是组件化。整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。最原始的组件，其功能可以单独开发测试，然后逐级拼装成更复杂的组件，直到整个应用。每一级都是易装配，可追踪，可管控的。组件化的目标有分治和复用，其中分治的价值更大。由于组件设计需要更高的成本和更高的难度，所以对web应用“全组件化”是有一定的难度的，可综合考虑。<br>所谓业务模型指的是所处领域中的业务数据、规则、流程的集合。目前解决业务模型的方法有flux、redux之类的架构。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>效率分为开发效率和运行效率。开发效率与选用的框架、技术以及组件化等都有很大的关系。运行效率主要因素有数据变更检测方式和创建、修改DOM。数据变更检测方式和框架有很大的关系，创建DOM的过程中，各个框架之间没有太大差异，而在修改DOM的时候，React的虚拟DOM有很大的优秀，其他框架内部实现也在逐渐借鉴。</p>
<h2 id="常见的架构"><a href="#常见的架构" class="headerlink" title="常见的架构"></a>常见的架构</h2><p>目前在Web应用中，常用的架构有MVC、MVP、MVVM三种。下面这两篇文章讲的很好。<br><a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" target="_blank" rel="external">Scaling Isomorphic Javascript Code</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></p>
<h2 id="开发框架与类库"><a href="#开发框架与类库" class="headerlink" title="开发框架与类库"></a>开发框架与类库</h2><p>通常，我们会开始用类库和框架来解决构建动态应用的问题。类库是一些函数的集合，它可以帮助我们写Web应用，但起主导作用的是我们的代码，如jQuery。而框架是一种特殊的、已经实现了的Web应用，它只需要填充具体的业务逻辑，其主导作用的是框架。</p>
<ul>
<li>ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成前端的开发以及布局。然而，随着功能的逐渐增加，ExtJS的体积变得日益庞大，性能也变得越来越差。</li>
<li>React可以认为是MVC中的V视图，其产生的意义是：解决构建随时间数据不断变化的大规模应用程序的问题。其主要特点是组件化（也可以使用其独有的jsx）和虚拟DOM树（只会更新需要更新的DOM，节省大量的DOM修改的时间）。React推崇的是单向数据流：给定原始界面，施加一个变化，就可以推导出顶一个状态（界面或数据的更新）</li>
<li>Angular是为了克服HTML在构建应用上的不足而设计的。它采用了MVVM的架构，采用了数据与界面的双向数据绑定，当界面发生变化时，按照配置规则去更新相应的数据，然后，在根据配置好的规则，把数据更新到界面状态。</li>
<li>Vue是一个构建数据驱动的web界面的库。Vue.js的目标是通过尽可能简单的API实现相应的数据绑定和组合的视图组件。它只聚焦于视图层，非常容易与其他库或已有项目整合。其核心是一个响应的数据绑定系统，它让数据与DOM保持同步变得非常简单。<a href="http://cn.vuejs.org/guide/comparison.html" target="_blank" rel="external">与其他框架的对比</a></li>
<li>jQuery是一个优秀的JavaScript库，它是轻量级的js库，兼容CSS3以及各种浏览器。jQuery是用户能更方便地处理HTML、events、实现动画效果和AJAX交互。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/WebApp/" data-id="cir0r643a003bn4q9j6l8itux" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flexbox" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/flexbox/" class="article-date">
  <time datetime="2016-04-23T05:26:23.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/flexbox/">flexbox</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文大量参考了Helen Emerson的<a href="http://helephant.com/2013/03/23/css3-flexbox-layout/" target="_blank" rel="external">《Using the CSS3 flexbox layout》</a>，如有需要，请移步此文。</p>
<h2 id="Flexbox简述"><a href="#Flexbox简述" class="headerlink" title="Flexbox简述"></a>Flexbox简述</h2><p>Flexbox的布局是一个用于页面布局的CSS3模块，目前为止，大部分的浏览器都支持或部分支持此功能，支持情况请参考<a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">caniuse网站</a>。Flexbox可以简单快速的创建一个具有弹性功能的布局，当在一个小屏幕上显示的时候，Flexbox可以让元素在伸缩容器中进行自由扩展和收缩，从而调整整个布局。</p>
<h2 id="伸缩容器和伸缩项目"><a href="#伸缩容器和伸缩项目" class="headerlink" title="伸缩容器和伸缩项目"></a>伸缩容器和伸缩项目</h2><p>一个flexbox布局由伸缩容器和其中的伸缩项目组成。伸缩容器是一个HTML标签元素，并且“display”属性显示设置“flex”属性值，伸缩容器中的所有子元素都会自动变成伸缩项目（flex items）。</p>
<h2 id="伸缩方向与换行（flex-flow）"><a href="#伸缩方向与换行（flex-flow）" class="headerlink" title="伸缩方向与换行（flex-flow）"></a>伸缩方向与换行（flex-flow）</h2><p>伸缩容器有一个CSS属性“flex-flow”用来决定伸缩项目的布局方式。常见的flex-flow的值有row、column、row wrap等，其伸缩项目排列方式如下：</p>
<p><img src="/img/CSS3/flexflow-row.png" alt="flex-flow:row"><br><img src="/img/CSS3/flex-flow-column.png" alt="flex-flow:column"><br><img src="img/CSS3/flexbox-rowwrap.png" alt="flex-flow:row wrap"></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row; <span class="comment">//还有columen、warp、row warp等</span></span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">1000px</span>; <span class="comment">//还可以使用max-widht等属性设置最大/最小宽度/高度等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伸缩项目设置"><a href="#伸缩项目设置" class="headerlink" title="伸缩项目设置"></a>伸缩项目设置</h2><p>伸缩容器中的所有子元素都将自动变成伸缩项目，仅需要设置伸缩项目的尺寸即可。设置其尺寸可以使用widht、height等固定伸缩项目的宽和高，也可以使用flex属性（还可以结合min-widht等属性）动态改变伸缩项目的尺寸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row wrap；</span><br><span class="line">	max-width: <span class="number">1500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">min-width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-widht</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">	<span class="attribute">min-widht</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSS3/flex-item-width.png" alt=""><br>在以上容器中，为left right都设置flex，最小/最大宽度，而mian设置了固定宽600px。其排列规则如下（在chrome中验证）：</p>
<ol>
<li>当宽度足够宽时，先去除main的600px固定宽，left和right宽度比为1:2（超过max-widht，长度自动设为max-width的值）。</li>
<li>当宽度不足时，优先满足left的min-widht和mian的widht。如果无法满足right的min-widht，right转到第二行。一次类推。</li>
<li>所以，可以结合min-widht、max-widht和flex动态调整元素大小，并使元素不至于过大或者过小。</li>
<li>计算规则为先按照flex分配元素尺寸（如果只有一个flex，则其填充剩余空白），然后参考最大最小尺寸，确定元素尺寸。每个元素都自动有一个隐式的最小尺寸，这里需要注意一下。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/flexbox/" data-id="cir0r643c003dn4q94w56m5ra" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/react-learn/" class="article-date">
  <time datetime="2016-04-17T13:13:55.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/react-learn/">react初步认识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React起源于Facebook的内部项目，其设计思想及其独特，属于革命性创新，性能出众，代码逻辑简单。其主要优点有：</p>
<ol>
<li>虚拟DOM，在必要的时候才将组件渲染到真正的DOM上，减少频繁的DOM操作造成的性能问题。</li>
<li>组件化，React都是关于构建可复用的组件。事实上，通过React唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离更加简单。</li>
</ol>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
    &lt;script src=&quot;http://fb.me/react-0.13.0.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;http://fb.me/JSXTransformer-0.13.0.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/jsx&quot;&gt;
      var HelloWorld = React.createClass({
          render: function() {
            return (
                  &lt;p&gt;
                    Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot; /&gt;!
                    It is {this.props.date.toTimeString()}
                  &lt;/p&gt;
            );
          }
        });

        setInterval(function() {
              React.render(
                &lt;HelloWorld date={new Date()} /&gt;,
                document.getElementById(&apos;example&apos;)
              );
        }, 500);

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>React提供了一个官方例子<a href="http://reactjs.cn/react/blog/2013/11/05/thinking-in-react.html" target="_blank" rel="external">英文</a><a href="http://reactjs.cn/react/docs/thinking-in-react.html" target="_blank" rel="external">中文</a>，从如何拆分组件树、如何利用React创建静态版本、如何识别最小的state、如何确认state的声明周期到添加方向数据流，较完整的展现了react的应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/17/react-learn/" data-id="cir0r644m0051n4q9ey7ulbmg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端框架/">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-async" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-async/" class="article-date">
  <time datetime="2016-04-14T19:25:50.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-async/">ECMAScript6中的异步操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>Generator函数是ES6提供的一种异步编程解决方案，我们可以将Generator函数理解成一个状态机，执行这个函数会返回一个遍历器对象。Generator函数内部使用yield语句，没执行一次函数的next方法，执行到下一个yield，直到函数结束，从而达到异步调用函数的目的。此外，yield本身没有返回值，next方法可以带一个参数，该参数将被当做上一个yield语句的返回值，实现在generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般与for of结合的使用方法，不需要使用next方法</span></span><br><span class="line"><span class="built_in">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="built_in">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);  <span class="comment">//在generator函数中调用另一个generator函数，要使用yield*</span></span><br><span class="line">    &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125; <span class="comment">//1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过next函数注入不同的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; 5+24+13=42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数的改写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> loader = loadUI();</span><br><span class="line"></span><br><span class="line">loader.next();<span class="comment">// 加载UI</span></span><br><span class="line">loader.next(); <span class="comment">//// 卸载UI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部署Ajax操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="built_in">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response); <span class="comment">//将response作为值传入</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">//执行request操作</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。Promise独享的状态（pending、resolved、rejected）不受外界影响，只有异步操作的结果可以决定当前是哪一种状态。一旦状态发生改变，就不再变。如果某些事件不断反复发生，一般阿狸说，使用stream模式比部署Promise更好。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line"><span class="built_in">var</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">//接收一个函数，函数有两个参数</span></span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">//接收两个函数，分别在成功和失败的时候执行</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步加载图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + <span class="built_in">url</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = <span class="built_in">url</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//generator和promise的结合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="decorator"><span class="keyword">try</span></span> &#123;</span><br><span class="line">    <span class="built_in">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h2 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h2><p>ES6之前，异步编程的方法，大概有：回调函数、事件监听、发布/订阅、Promise对象，ES6则应用generator函数是异步编程进入全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="comment">//1.回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise</span></span><br><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); <span class="comment">//读入A后，读取B，则会出现多重嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.协程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.generator</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.Async</span></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>); <span class="comment">//await表示紧跟后面的表达式需要等待结果</span></span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>); <span class="comment">//返回Promise对象，如果不是，则转为promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-async/" data-id="cir0r6415000on4q9ihl6nodp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/ECMAScript6-class/" class="article-date">
  <time datetime="2016-04-14T19:24:56.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/ECMAScript6-class/">ECMAScript6中的Class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本质上，ES6只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性，Class和let一样，不存在变量提升。ES6实现了类的继承，类的静态方法，但是目前没有规定类的静态属性，在ES7中，有关于静态属性的提议。</p>
<h2 id="Class类基础"><a href="#Class类基础" class="headerlink" title="Class类基础"></a>Class类基础</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line">Class  Point &#123; <span class="comment">//其实它可以看做构造函数的另一种写法。</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x; <span class="comment">//显示定义在本身，而不是原型上</span></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; <span class="comment">//class这种写法，方法是不可枚举的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>Class之间可以通过extends关键字实现继承。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">//this是继承父类的this对象，然后对其进行加工</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// super代表父类实例，调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的prototype和proto属性"><a href="#类的prototype和proto属性" class="headerlink" title="类的prototype和proto属性"></a>类的prototype和<em>proto</em>属性</h2><p>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。一、子类的<em>proto</em>属性，表示构造函数的继承，总是指向父类。二、子类prototype属性的<em>proto</em>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。父类的静态方法，可以被子类继承。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod() <span class="comment">//typeeror static方法不会被实例继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> super.classMethod()+<span class="string">'too'</span>; <span class="comment">//可以从super对象上调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod() <span class="comment">//'hello' static方法可以被子类继承，</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/ECMAScript6-class/" data-id="cir0r641w001qn4q9yz8vs3yf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6-iterator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6-iterator/" class="article-date">
  <time datetime="2016-04-14T13:28:33.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6-iterator/">ECMAScript6新属性方法等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6中添加了一些新的结构、属性、方法等，下面将进行简单的说明。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES5的对昂属性名都是字符串，容易造成属性名的冲突。ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，它是JavaScript的第七种数据类型，通过Symbol函数生成。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'Hello!'</span>&#125;; <span class="comment">//symbol属性不能使用.运算符</span></span><br><span class="line">a[mySymbol] <span class="comment">//"Hello!" symbol属性不能使用.运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>); <span class="comment">//必须都是用for，且输入值相同，才相等</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 == s2  <span class="comment">//true 使用symbol.for可以实现两个symbol相同</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">//"foo" sysmol.for()有登记制，symbol()没有，登记的会返回字符串参数</span></span><br></pre></td></tr></table></figure>
<h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h4 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h4><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set的方法有四个：set.add(value)、set.delete(value)、set.has(value)、set.clear()清除所有成员。如果要读取或者遍历可以将set通过Array.from(set)转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">"4"</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>]);</span><br><span class="line">alert(set.size); <span class="comment">//6 在set内部，4不等于“4”（不会发生类型转换），NaN等于NaN，对象总是不等于对象&#123;&#125;不等于&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>)</span>&#123; <span class="comment">//数组去重的方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet与Set类似，也是不重复的值的集合，但是它与Set有两个区别。一、WeakSet的成员只能是对象。二、WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]; <span class="comment">//数组的成员只能是对象，不能是变量</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br></pre></td></tr></table></figure>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。ES6提供了Map数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键，是一种更完善的Hash结构实现。<br>Map原生提供三个遍历器生成函数和一个遍历方法。entries()、keys()、values()、forEach()。<br>Map可以与数组、对象、Json相互转换。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">m</span> = new Map();</span><br><span class="line"><span class="keyword">var</span> o = &#123;p:<span class="string">"hello tecent"</span>&#125;;</span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">set</span>(o,<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">m</span>.<span class="built_in">get</span>(o); <span class="comment">//"content"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">m</span>.size <span class="comment">//1</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.delete(o); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">m</span>.has(o); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">m</span>.<span class="keyword">clear</span>(); <span class="comment">//全部清空</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap与Map结构基本类似，唯一的区别是它只接受对象做为键名(null除外)，而且键名所指向的对象，不计入垃圾回收机制。其设计目的在于，键名是对象的弱引用。</p>
<h2 id="Iterator遍历器与for…of循环"><a href="#Iterator遍历器与for…of循环" class="headerlink" title="Iterator遍历器与for…of循环"></a>Iterator遍历器与for…of循环</h2><p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。其遍历过程如下：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象（字符串等）、Set和Map结构。另外，也可以手动为对象等添加Iterator接口。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = ['a', 'b'];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="type">Symbol</span>.<span class="keyword">iterator</span>](); //默认的<span class="type">Iterator</span>接口部署在数据结构的<span class="type">Symbol</span>.<span class="keyword">iterator</span>属性</span><br><span class="line">iter.next() // &#123; value: 'a', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: 'b', done: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr =['b','c'];</span><br><span class="line">['a',…arr,'d'] //['a','b','c','d'] 扩展运算符会调用默认的<span class="keyword">iterator</span>接口</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = ['a', 'b', 'c', 'd'];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">in</span>循环，只获得对象的键名</span><br><span class="line">  console.log(a); // <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;  //<span class="keyword">for</span> <span class="keyword">of</span>循环，获得对象的键值，只返回具有数字索引的属性</span><br><span class="line">  console.log(a); // a b c d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = new <span class="type">Map</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [name,value] <span class="keyword">of</span> map)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6-iterator/" data-id="cir0r640y000fn4q9wxsut3jo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ECMAScript6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/ECMAScript6/" class="article-date">
  <time datetime="2016-04-14T07:35:01.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/ECMAScript6/">ECMAScript6为数据类型添加的新方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript6在2015年6月正式发布。它的目标，是是的JavaScript语言可以用来编写复杂的大型应用陈旭，称为企业级开发语言。ECMAScript是JavaScript的规格，后者有时前者的一种实现。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><p>ES6新增let命令，用来声明变量，用法类似于var。区别为：</p>
<ul>
<li>let所声明的变量，只在let命令所在的代码块内有效。</li>
<li>let不存在“变量提升”现象，即其变量的定义是在JavaScript的代码执行阶段。</li>
<li>let存在暂时性死区，即又要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。</li>
<li>let实际上为JavaScript新增了块级作用域；<br>如此便解决了块级局部变量以及for循环中局部变量的问题。解决了如下一个大问题：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">//i为局部变量，</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">5</span>](); <span class="comment">//5，每次的i都是一个新的变量</span></span><br></pre></td></tr></table></figure>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p>const用来定义常量，一旦声明，常量的值就不能改变。</p>
<ul>
<li>严格模式下，重新赋值会报错，常规模式下，赋值无效不报错；</li>
<li>const声明时不赋值则不能赋值，常量为undefind。严格模式下，const声明时必须赋值，否则报错；</li>
<li>const存在块级作用域。</li>
</ul>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。可以用于交换变量的值、从函数返回多个值、函数参数定义、解析jsondata等。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]]; </span><br><span class="line">bar <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>]; <span class="comment">//a=1,b=undefined</span></span><br><span class="line"><span class="keyword">var</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//解构不完全，但可以成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认值</span></span><br><span class="line"><span class="keyword">var</span> [c=<span class="number">1</span>,d=<span class="number">2</span>,e=<span class="number">3</span>] = [<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="number">5</span>]; <span class="comment">//1,null,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用途</span></span><br><span class="line">[x,y] = [y,x]; <span class="comment">//交换变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a,b,c] = example(); <span class="comment">//从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x,y,z])</span></span>&#123;……&#125;</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">//函数参数定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析jsondata等</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>String类型主要添加了遍历字符、字符串的头尾判断、字符串重复、字符的有关Unicode表示等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(codePoint); <span class="comment">//分别显示 f o o ，遍历字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s=<span class="string">'Hello world'</span>;</span><br><span class="line">s.startWith(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line">s.endWith(<span class="string">'Hello'</span>,<span class="number">5</span>); <span class="comment">//true,可以添加第二个参数，表示搜索的位置。</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>); <span class="comment">//"hellohello"</span></span><br></pre></td></tr></table></figure>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>新增了是否为无穷、NaN判断，是否为整数，安全整数，另外，parseInt()、parseFloat()方法也放到了Number对象的下面。Math对象的话则添加了获取整数部分，返回正负值，立方根、对数等。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> // <span class="number">0b</span>二进制 <span class="literal">true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> // <span class="number">0o</span>八进制 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Number.isFinite(<span class="number">0.8</span>); //<span class="literal">true</span> 是否为非无穷,检查Infinate特殊值</span><br><span class="line">Number.isNaN(NaN); //<span class="literal">true</span> 是否为NaN，检查NaN特殊值</span><br><span class="line"></span><br><span class="line">Number.parseInt('<span class="number">12.34</span>'); //<span class="number">12</span> 将全局方法parseInt()、parseFloat()，移植到Number对象上</span><br><span class="line">Number.parseFloat('<span class="number">12.45</span>#'); //<span class="number">12.45</span></span><br><span class="line"></span><br><span class="line">Number.isInteger(<span class="number">3.0</span>); //<span class="literal">true</span> 是否为整数，JavaScript中，整数和浮点数使用同样的存储方法，所以<span class="number">3</span>和<span class="number">3.0</span>视为一个值</span><br><span class="line">Number.isSafeInteger(Math(<span class="number">2</span>,<span class="number">53</span>)-<span class="number">1</span>); /<span class="literal">true</span>，JavaScript能够精确表示-<span class="number">2</span>^<span class="number">53</span>到-<span class="number">2</span>^<span class="number">53</span>间的整数（不含端点），超过则无法精确表示这个值</span><br><span class="line"></span><br><span class="line">Math.<span class="built_in">trunc</span>(<span class="number">4.1</span>); //<span class="number">4</span> 用于取出一个数的小数部分，返回整数部分</span><br><span class="line">Math.<span class="built_in">sign</span>(-<span class="number">5</span>); //-<span class="number">1</span> 参数为正数返回+<span class="number">1</span> 其他返回+<span class="number">0</span>、<span class="number">0</span>、+<span class="number">0</span>、-<span class="number">1</span>和NaN</span><br><span class="line">Math.cbrt(<span class="number">2</span>); //<span class="number">1.2599210498948734</span> 返回一个数的立方根</span><br><span class="line"></span><br><span class="line">//还有对数方法、关于<span class="number">32</span>位无符号数的方法等</span><br></pre></td></tr></table></figure>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>新增了将类数组转换为数组、将一组值转换为数组的方法，通过find()查找第一个符合条件的数组成员，通过fill填充数组，还可以通过entries()等方法返回键值对数组等。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike=&#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="string">'2'</span>:<span class="string">'c'</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line">var arr1 = [].slice.call(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES5</span>的方法</span><br><span class="line">let arr2 = <span class="symbol">Array</span>.from(arrayLike); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>] <span class="symbol">ES6</span>的方法</span><br><span class="line"><span class="symbol">Array</span>.from(<span class="string">'abcde'</span>); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br><span class="line"><span class="symbol">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x); //[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>] 接收第二个参数，对每个元素进行处理</span><br><span class="line"></span><br><span class="line"><span class="symbol">Array</span>.of(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>); //[<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>] 将一组值，转换为数组，主要目的是弥补数组构造函数<span class="symbol">Array</span>()的不足</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find((n) =&gt; n&lt;<span class="number">0</span>); //<span class="number">-5</span> 用于找出第一个符合条件的数组成员</span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>); //[<span class="string">'a'</span>,<span class="number">7</span>,<span class="string">'c'</span>] 第一个参数表示填充值，剩下两个表示填充起始位置和结束位置</span><br><span class="line"></span><br><span class="line">//entries() keys() values()用于遍历数组，分别表示遍历键值对、键、值</span><br><span class="line">for(let [index,elem] of [<span class="string">'a'</span>,<span class="string">'b'</span>].entries())&#123;</span><br><span class="line">	console.log(index,elem);</span><br><span class="line">&#125; //<span class="number">0</span> <span class="string">"a"</span>   <span class="number">1</span>  <span class="string">"b"</span> </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>); //true 是否包含给定数值</span><br></pre></td></tr></table></figure>
<h2 id="函数参数的扩展"><a href="#函数参数的扩展" class="headerlink" title="函数参数的扩展"></a>函数参数的扩展</h2><p>函数中新增了设置参数默认值、rest参数等功能，并且新增了箭头函数，尾递归优化等，并且可以通过函数的length属性获取其无默认值参数的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = 0, y = 0</span>) </span>&#123; <span class="comment">//设置参数默认值</span></span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">5</span>); <span class="comment">//p.x=5,p.y=0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常定义了默认值的参数，应该是函数的尾参数，因为输入f(,)这种没有赋值的函数会出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y=1</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [x,y];</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">//[2,1] 这样就可以省略尾部的有默认值的参数</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=1</span>)</span>&#123;&#125;&#125;).length <span class="comment">//2 返回没有指定默认值的参数个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定参数是否可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//会抛出错误，因为mustBeProvided默认值为抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量数量不定，rest参数。values变量表示一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">var</span> f = v =&gt; v*v; <span class="comment">//f(2)等于4</span></span><br><span class="line"><span class="keyword">var</span> sum = (num1,num2) =&gt; num1+num2 <span class="comment">//等同于下面</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1,num2</span>)</span>&#123; <span class="keyword">return</span> num1+num2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，只保留一个调用记录（严格模式下开启），复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>对象的扩展对象合并、属性遍历、返回对象键值数组等</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">//true 只要两个值一样，就相等，不同于===</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">"12"</span>,<span class="number">12</span>) <span class="comment">//false 不进行自动转换类型，不同于==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象合并，常用于为对象添加属性和方法以及克隆对象等</span></span><br><span class="line"><span class="built_in">var</span> target = &#123; <span class="attribute">a</span>: <span class="number">1</span>, <span class="attribute">b</span>: <span class="number">1</span> &#125;; <span class="comment">//合并对象，只是浅复制</span></span><br><span class="line"><span class="built_in">var</span> source1 = &#123; <span class="attribute">b</span>: <span class="number">2</span>, <span class="attribute">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1); <span class="comment">//&#123; a:1, b: 2, c: 2&#125;将后面的对象都复制到第一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的遍历</span></span><br><span class="line"><span class="keyword">for</span>……<span class="keyword">in</span> <span class="comment">//遍历对象自身和继承的可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)  <span class="comment">//返回一个数组，包含对象自身（不含继承的）所有可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)  <span class="comment">//返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象的键值对数组、键数组和值数组</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">//返回obj对象的值数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">//返回obj对象的键数组</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">//[["a","1"],["b",2]] 返回obj对象的值数组</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/ECMAScript6/" data-id="cir0r641d000wn4q9wlzbizcx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript-crossOrigin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/JavaScript-crossOrigin/" class="article-date">
  <time datetime="2016-04-11T04:38:02.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端开发/">前端开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/JavaScript-crossOrigin/">同源策略与跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略为JavaScript文件只能访问与其同源的资源和数据。同源策略浏览器最核心也是最基本的安全功能，其目的是为了防止恶意网站窃取数据。所谓同源是指协议、域名、端口都相同。IE关于同源不要求端口相同。</p>
<h4 id="同源禁止的行为"><a href="#同源禁止的行为" class="headerlink" title="同源禁止的行为"></a>同源禁止的行为</h4><p>考虑同源，要考虑三个部分：不同源的服务器、不同源的窗口和文档、不同源的存储数据。一般情况下，同源策略禁止以下行为：</p>
<ul>
<li>禁止JavaScript访问不同源的Cookie、LocalStorage以及IndexDB等存储数据。</li>
<li>禁止读取和操作与JavaScript脚本不同源的窗口和文档的大多数属性。</li>
<li>禁止XMLHttpRequest生成的HTTP请求与不同源的服务器通信。（如果允许，就可以在控制台写个ajax提交到任意的服务器了）</li>
</ul>
<h4 id="同源策略允许的行为"><a href="#同源策略允许的行为" class="headerlink" title="同源策略允许的行为"></a>同源策略允许的行为</h4><p>同源策略控制了不同源之间的交互，但是并非限制了所有不同源的交互。通常允许以下行为：</p>
<ul>
<li>通常允许跨域写操作，例如链接、重定向以及表单提交。特定少数的HTTP请求需要添加preflight。</li>
<li>通常允许跨域资源嵌入。例如利用script、link、img、iframe、video、audio等标签嵌入不同域的资源（可以设置资源是否可以被其他域访问）。这种内嵌资源的获取和访问是由浏览器来完成的，所以是安全的。此外，通过&lt; script&gt;标签等引入的JavaScript、CSS、图像等静态资源也被认为是与包含它们的界面所在的域同源。</li>
<li>通常不允许跨域读操作。但常可以通过内嵌资源进行读取访问，如调用内嵌脚本的方法（JSONP）。</li>
</ul>
<h4 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h4><p>严格来说，同源策略用于JavaScript脚本，所以使用script、img等标签进行跨域资源嵌入是与同源策略无关的。那么别人也就可以在他们的页面上引用我们的服务器的图片了，但是如果我们不想给他们用呢？在请求头中，有个字段为referer，采用url的格式表示发送请求的网页或文件，我们可以在服务器代码中检查referer的值，来决定是否让这些网站使用。这就是防盗链的原理。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域利用一定的方法和技术，使JavaScript脚步可以访问获取原本不同源的服务器、窗口和文档、存储数据的内容。常用的方法有设置相同的域、跨域资源共享、JSONP、跨文档信息、WebSockets等。</p>
<h4 id="变更源"><a href="#变更源" class="headerlink" title="变更源"></a>变更源</h4><p>同源限制的是不同源内容之间的访问，那么我们只需要将两个页面的源设成一致就可以相互访问了。<br><em>实现方法：</em>通过JavaScript，将A页面和B页面的document.domain设置为相同的域名。<br><em>限制及适用范围：</em></p>
<ul>
<li>同个网页的一级域名需要相同。如<a href="http://store.company.com/dir/other.html的域名可以设置为`document.domain" target="_blank" rel="external">http://store.company.com/dir/other.html的域名可以设置为`document.domain</a> = “company.com”`，但是不能设置为othercompany.com。另外赋值时，会以null覆盖原来的端口号，所以赋值时要带上端口号</li>
<li>此方法只适用于Cookie和窗口，LocalStorage和IndexDB无法通过此方法规避同源，而要使用PostMessage。</li>
<li>也可以在服务器设置Cookie时，指定Cookie的所属域名为一级域名，这样只有一级域名相同，就可以访问该Cookie。</li>
</ul>
<h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><p>跨域资源共享是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同域访问其资源。而这种访问是同源策略所禁止的。它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。跨域资源共享的基本思想，是通过自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是否应该成功。<br>默认情况下，XHR对象只能访问与包含它的页面位于同一域中的资源，所以通过xhr.open()打开的是相对路径的url，如果浏览器支持CORS，则可以将url设置为指向其他域资源的绝对路径的url。将请求发送给服务器后，服务器会根据这个头部信息(Origin，说明请求的源)决定是否给予响应，可以接受的话，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回*），如果没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。<br>与JSONP相比，CORS无疑更加先进：</p>
<ol>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，开发者可以使用普通的xhr对象发起请求和获得数据，比起JSONP有更好的错误处理。</li>
</ol>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是JSON with padding的简写，是应有JSON的一种方法。JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。JSONP是通过动态&lt; script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。<br>总的来说，JSONP是一种在客户端定义函数，在服务器端传入数据并传递到客户端调用该函数的一种方式。所以JSONP要求服务器和客户端的密切配合，并且只能实现GET请求。且数据格式要为可以通过script标签传递的JSONP格式。<br>实例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//客户端</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"divCustomers"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callbackFunction</span>(<span class="params">result, methodName</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> html = <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                html += <span class="string">'&lt;li&gt;'</span> + result[i] + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            html += <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'divCustomers'</span>).innerHTML = html;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//服务器端</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-type: application/json'</span>);</span><br><span class="line"><span class="comment">//获取回调函数名</span></span><br><span class="line">$jsoncallback = htmlspecialchars($_REQUEST [<span class="string">'jsoncallback'</span>]);</span><br><span class="line"><span class="comment">//json数据</span></span><br><span class="line">$json_data = <span class="string">'["customername1","customername2"]'</span>;</span><br><span class="line"><span class="comment">//输出jsonp格式的数据</span></span><br><span class="line"><span class="keyword">echo</span> $jsoncallback . <span class="string">"("</span> . $json_data . <span class="string">")"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>Web Sockets的目标是在一个单独的持久连接上提供双工、双向通信。使用标准的HTTP服务器无法实现Web Sockets，只要支持这种协议的专门服务器才能正常工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket=<span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">socket.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> data = event.data;</span><br><span class="line">	<span class="comment">//处理数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h4><p>HTML5为解决文档间的通信问题，引入了一个全新的API，它为window对象新增了一个window.postMessage方法，允许跨域的窗口通信。<br>父窗口可以使用window.open()或iframe等打开一个不同源的子窗口，则父窗口和子窗口可以进行通信。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父窗口http://a.com脚本</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://b.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">popup.postMessage(<span class="string">'hello b'</span>, <span class="string">'http://b.com'</span>);<span class="comment">//向子窗体发送信息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; <span class="built_in">console</span>.log(e); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子窗口http://b.com脚本</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'hello a'</span>, <span class="string">'http://a.com'</span>);<span class="comment">//向父窗体发送信息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin = <span class="string">"http://a.com"</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同源策略是限制JavaScript脚本访问不同源的资源的一种安全措施，是web安全的基石。所以script、img等标签不受同源策略的限制（因为其资源的请求是浏览器发起的，是安全的），但是可以通过防盗链技术（检查请求头的referer）来限制我们的资源被其他网页的使用的权限。<br>同源策略限制JavaScript脚本访问不同源的存储数据（Cookie、LocalStorage、IndexDB）、窗口和文档（其绝大部分属性）以及服务器资源（XMLHttpRequest发起的请求要同源），以防止恶意的网址获取用户的信息。但是，实现合理的跨域请求也是必须的。<br>为了使同一个一级域名下网站间进行相互访问，可以将其子网址的域名通过document.domain统一设为一级域名，子网站间就不再受同源限制了。为了使Ajax发起不同源的请求，可以使用跨域资源共享方法，设置Orign和Access-Control-Allow-Origin头部来指定该服务器信任的网站，也可以使用JSONP，但它有很大的限制。此外，也可使用WebSocket来实现客户端与服务器端的通信，它不实行同源策略。为了不同网页间进行信息传输，则可以使用postMessage方法来实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/11/JavaScript-crossOrigin/" data-id="cir0r642y002tn4q9x8b50dlf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域/">跨域</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ext-Ajax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/Ext-Ajax/" class="article-date">
  <time datetime="2016-04-07T13:36:29.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ExtJS/">ExtJS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/Ext-Ajax/">Ext中Ajax技术详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ajax技术的核心是XMLHttpRequest对象。原生JavaScript实现Ajax的流程为：创建XHR对象实例，实例使用open()方法（设定发送请求类型、URL以及是否异步），然后使用send()方法传送相应数据，即完成请求。接下来，通过检查xhr实例的状态，判断是否返回所需值，并对response进行解析，执行相应操作即完成了Ajax通信过程。ExtJS以及jQuery等库都对Ajax过程进行了不同程度的封装，以简化异步请求过程。</p>
<h2 id="ExtJS的Ajax使用方法简介"><a href="#ExtJS的Ajax使用方法简介" class="headerlink" title="ExtJS的Ajax使用方法简介"></a>ExtJS的Ajax使用方法简介</h2><p>ExtJS的封装比较完全，目前ExtJS进行异步通信的常规手段都是采用Model+Store的方式，对组件内容进行动态更新，已经比较少使用Ext.Ajax的方法了。但前一种方式只是对Ext.Ajax方法的进一步封装，其实现原理类似，故此处仍然先对Ext.Ajax进行说明。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是主要的属性和方法，此外还有failure等</span></span><br><span class="line">Ext.Ajax.request(&#123;</span><br><span class="line">    <span class="attribute">url</span>: <span class="string">'page.php'</span>,  <span class="comment">//设置url，可以带请求参数</span></span><br><span class="line">    <span class="attribute">method</span>: <span class="string">"get"</span>, <span class="comment">//设置请求方法</span></span><br><span class="line">    <span class="attribute">params</span>: &#123; <span class="comment">//设置要发送的参数，可发送多个参数</span></span><br><span class="line">        <span class="attribute">id:</span><span class="emphasis"> 1</span><br><span class="line">    &#125;,</span><br><span class="line">    success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123; <span class="comment">//请求的数据返回成功则执行</span></span><br><span class="line">        <span class="built_in">var</span> text = response.responseText;</span><br><span class="line">        <span class="comment">// process server response here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="ExtJS的Ext-Ajax-request底层实现"><a href="#ExtJS的Ext-Ajax-request底层实现" class="headerlink" title="ExtJS的Ext.Ajax.request底层实现"></a>ExtJS的Ext.Ajax.request底层实现</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">request</span> : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">        options = options || &#123;&#125;;</span><br><span class="line">        <span class="built_in">var</span> me = <span class="keyword">this</span>,</span><br><span class="line">            scope = options.scope || <span class="built_in">window</span>,</span><br><span class="line">            username = options.username || me.username,</span><br><span class="line">            password = options.password || me.password || <span class="string">''</span>,</span><br><span class="line">            <span class="keyword">async</span>,</span><br><span class="line">            requestOptions,</span><br><span class="line">            request,</span><br><span class="line">            headers,</span><br><span class="line">            xhr;</span><br><span class="line">        <span class="keyword">if</span> (me.fireEvent(<span class="string">'beforerequest'</span>, me, options) !== <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">            requestOptions = me.setOptions(options, scope);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (me.isFormUpload(options)) &#123;</span><br><span class="line">                me.upload(options.form, requestOptions.url, requestOptions.data, options);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果设置了自动取消异步，则调用abort()方法，取消异步请求</span></span><br><span class="line">            <span class="keyword">if</span> (options.autoAbort || me.autoAbort) &#123;</span><br><span class="line">                me.abort();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">async</span> = options.async !== <span class="literal">false</span> ? (options.async || me.async) : <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 创建一个XHR对象实例，此处多了用户名和密码两个参数</span></span><br><span class="line">            <span class="comment">// 函数进行性能检测，ie返回的是xdr实例，存在xhr返回xhr实例</span></span><br><span class="line">            xhr = me.openRequest(options, requestOptions, <span class="keyword">async</span>, username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不是XDR，则设置相应头部</span></span><br><span class="line">            <span class="keyword">if</span> (!me.isXdr) &#123;</span><br><span class="line">                headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建请求实例</span></span><br><span class="line">            request = &#123;</span><br><span class="line">                <span class="attribute">id:</span><span class="emphasis"> ++Ext.data.Connection.requestId</span>, <span class="comment">//自动设置id以进行区分</span></span><br><span class="line">                <span class="attribute">xhr</span>: xhr,</span><br><span class="line">                <span class="attribute">headers</span>: headers,</span><br><span class="line">                <span class="attribute">options</span>: options,</span><br><span class="line">                <span class="attribute">async</span>: <span class="keyword">async</span>,</span><br><span class="line">                <span class="attribute">binary</span>: options.binary || me.binary,</span><br><span class="line">                <span class="attribute">timeout</span>: setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    request.timedout = <span class="literal">true</span>;</span><br><span class="line">                    me.abort(request);</span><br><span class="line">                &#125;, options.timeout || me.timeout)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            me.requests[request.id] = request;</span><br><span class="line">            me.latestId = request.id;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定statechange事件函数,状态发生改变则发生相应事件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">async</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!me.isXdr) &#123;</span><br><span class="line">                    xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me, [request]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果是XDR，则使用一下方法绑定request</span></span><br><span class="line">            <span class="keyword">if</span> (me.isXdr) &#123;</span><br><span class="line">                me.processXdrRequest(request, xhr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始进行请求</span></span><br><span class="line">            xhr.send(requestOptions.data);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">async</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> me.onComplete(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125; <span class="decorator"><span class="keyword">else</span></span> &#123;</span><br><span class="line">            Ext.callback(options.callback, options.scope, [options, <span class="literal">undefined</span>, <span class="literal">undefined</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="ExtJS中load-与reload"><a href="#ExtJS中load-与reload" class="headerlink" title="ExtJS中load()与reload()"></a>ExtJS中load()与reload()</h2><p>ExtJS可以通过store的load()和reload()方法隐式实现Ajax请求及响应，为对Ajax的应用级别的封装。下面为load()、reload()流程：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reload方法，为更改最新属性，再次使用load()方法</span></span><br><span class="line"><span class="attribute">reload</span>: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">var</span> o = Ext.apply(&#123;&#125;, options, <span class="keyword">this</span>.lastOptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.load(o);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">load</span>: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">var</span> me = <span class="keyword">this</span>,</span><br><span class="line">            operation = &#123;</span><br><span class="line">                <span class="attribute">action</span>: <span class="string">'read'</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (me.fireEvent(<span class="string">'beforeload'</span>, me, operation) !== <span class="literal">false</span>) &#123;</span><br><span class="line">            me.loading = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//调用read方法</span></span><br><span class="line">            me.proxy.read(operation, me.onProxyLoad, me);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> me;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Ajax请求</span></span><br><span class="line"><span class="attribute">read</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doRequest.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="attribute">doRequest</span>: <span class="function"><span class="keyword">function</span>(<span class="params">operation, callback, scope</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line"></span><br><span class="line">        Ext.Ajax.request(request);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/Ext-Ajax/" data-id="cir0r641k0014n4q90tnnk4lf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ajax/">Ajax</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ExtJS/">ExtJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端开发/">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ExtJS/">ExtJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端框架/">前端框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客搭建/">博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发基础/">软件开发基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Language/">C-Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C语言/">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExtJS/">ExtJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript-Prototype/">JavaScript Prototype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发/">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端开发，CSS3/">前端开发，CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端框架/">前端框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客搭建/">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机基础/">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发基础/">软件开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接集/">链接集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ajax/" style="font-size: 11.67px;">Ajax</a> <a href="/tags/BOM/" style="font-size: 10px;">BOM</a> <a href="/tags/C-Language/" style="font-size: 10px;">C-Language</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/C语言/" style="font-size: 11.67px;">C语言</a> <a href="/tags/ExtJS/" style="font-size: 13.33px;">ExtJS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 18.33px;">JavaScript</a> <a href="/tags/JavaScript-Prototype/" style="font-size: 10px;">JavaScript Prototype</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TCP-IP/" style="font-size: 11.67px;">TCP/IP</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/前端开发/" style="font-size: 20px;">前端开发</a> <a href="/tags/前端开发，CSS3/" style="font-size: 10px;">前端开发，CSS3</a> <a href="/tags/前端框架/" style="font-size: 11.67px;">前端框架</a> <a href="/tags/博客搭建/" style="font-size: 10px;">博客搭建</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/计算机基础/" style="font-size: 16.67px;">计算机基础</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/软件开发基础/" style="font-size: 10px;">软件开发基础</a> <a href="/tags/链接集/" style="font-size: 10px;">链接集</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/24/js-proto/">JavaScript原型</a>
          </li>
        
          <li>
            <a href="/2016/07/10/JS-timeout/">JavaScript计时</a>
          </li>
        
          <li>
            <a href="/2016/06/28/js-scope/">作用域</a>
          </li>
        
          <li>
            <a href="/2016/06/22/css-box/">CSS盒模型与布局</a>
          </li>
        
          <li>
            <a href="/2016/06/22/css-center/">CSS伸缩布局与居中</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Rancho<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>